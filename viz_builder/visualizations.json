{
  "b0739a1a-ca0a-41fa-9adb-dc05f84d6b85": {
    "id": "b0739a1a-ca0a-41fa-9adb-dc05f84d6b85",
    "created_at": "2025-04-07T19:05:22.433085",
    "updated_at": "2025-04-09T16:12:54.572040",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom PIL import Image\nimport warnings\nwarnings.filterwarnings('ignore')\n\nst.title(\"Image Compression with PCA\")\n\nst.write(\"This app demonstrates image compression using Principal Component Analysis (PCA). PCA reduces the dimensionality of the image data, allowing for smaller file sizes with some loss of detail.\")\n\n# Image Upload\nuploaded_file = st.file_uploader(\"Choose an image...\", type=[\"jpg\", \"jpeg\", \"png\"])\n\nif uploaded_file is not None:\n    image = Image.open(uploaded_file)\n    st.image(image, caption=\"Original Image\", use_container_width=True)\n\n    # Convert image to numpy array\n    img_array = np.array(image)\n\n    # Convert to Grayscale\n    if len(img_array.shape) == 3:\n        img_gray = np.dot(img_array[...,:3], [0.2989, 0.5870, 0.1140])\n    else:\n        img_gray = img_array\n\n    img_gray = img_gray.astype(np.uint8)\n\n    st.image(img_gray, caption=\"Grayscale Image\", use_container_width=True)\n    st.write(f\"Grayscale Image Shape: {img_gray.shape}\")\n\n    # Display the matrix of grayscale values\n    st.write(\"Grayscale Value Matrix:\")\n    st.dataframe(pd.DataFrame(img_gray))\n\n    # Number of components\n    n_components = st.slider(\"Number of Principal Components\", 1, img_gray.shape[1], img_gray.shape[1]//10)\n\n    # Reshape image into a matrix where each row is a pixel\n    img_matrix = img_gray\n\n    # Standardize the data\n    scaler = StandardScaler()\n    scaled_data = scaler.fit_transform(img_matrix)\n\n    # Apply PCA\n    pca = PCA(n_components=n_components)\n    pca.fit(scaled_data)\n    transformed_data = pca.transform(scaled_data)\n\n    # Inverse transform\n    inverse_data = pca.inverse_transform(transformed_data)\n\n    # Scale back to original range\n    inverse_data = scaler.inverse_transform(inverse_data)\n\n    # Clip values to be within the valid range\n    compressed_img = np.clip(inverse_data, 0, 255).astype(np.uint8)\n\n    # Display compressed image\n    st.image(compressed_img, caption=f\"Compressed Image with {n_components} Components\", use_container_width=True)\n\n    # Explained variance ratio\n    explained_variance = pca.explained_variance_ratio_\n    explained_variance_cumulative = np.cumsum(explained_variance)\n\n    # Plot explained variance\n    fig, ax = plt.subplots()\n    ax.plot(explained_variance_cumulative)\n    ax.set_xlabel(\"Number of Components\")\n    ax.set_ylabel(\"Cumulative Explained Variance\")\n    ax.set_title(\"Explained Variance vs. Number of Components\")\n    st.pyplot(fig)\n\n    # Display explained variance ratio data\n    variance_df = pd.DataFrame({'Component': range(1, len(explained_variance) + 1),\n                                  'Explained Variance': explained_variance,\n                                  'Cumulative Explained Variance': explained_variance_cumulative})\n    st.dataframe(variance_df)\n\n    # Compression Ratio\n    # The error was caused by trying to get the size of the uploaded file object directly.\n    # We need to save the file to a temporary location and then get the size.\n    temp_file = \"temp_image.jpg\"  # Or .png, depending on original\n    image.save(temp_file)\n    original_size = os.path.getsize(temp_file)\n    compressed_size = compressed_img.nbytes\n    compression_ratio = original_size / compressed_size\n    os.remove(temp_file)\n\n\n    st.write(f\"Original File Size: {original_size} bytes\")\n    st.write(f\"Compressed Image Size: {compressed_size} bytes\")\n    st.write(f\"Compression Ratio: {compression_ratio:.2f}\")\n\n    if st.button(\"Rerun\"):\n        st.rerun()\nelse:\n    st.write(\"Please upload an image to begin.\")",
    "title": "Image Compression with PCA using Streamlit",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "232d5513-d92f-42f1-a828-0a5f72a245b4": {
    "id": "232d5513-d92f-42f1-a828-0a5f72a245b4",
    "created_at": "2025-04-09T16:06:48.178903",
    "updated_at": "2025-07-24T09:57:41.127127",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Iris Dataset PCA Visualization\")\n\n# Load the Iris dataset\ntry:\n    iris_data = pd.read_csv('./upload/iris.csv')\nexcept FileNotFoundError:\n    st.error(\"The file 'iris.csv' was not found in the './upload/' directory.  Please upload the file or check the path.\")\n    st.stop()  # Stop execution if file is not found\n\nst.write(\"First 5 rows of the dataset:\")\nst.dataframe(iris_data.head())\n\n# Data Preprocessing\nfeatures = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width']\nX = iris_data[features]\ny = iris_data['Species']\n\n# Standardize the features\nfrom sklearn.preprocessing import StandardScaler\nX = StandardScaler().fit_transform(X)\n\n# PCA implementation\nfrom sklearn.decomposition import PCA\npca = PCA(n_components=2)\nprincipalComponents = pca.fit_transform(X)\nprincipalDf = pd.DataFrame(data = principalComponents, columns = ['PCA1', 'PCA2'])\n\n# Concatenate with species information\nfinalDf = pd.concat([principalDf, iris_data[['Species']]], axis = 1)\n\nst.subheader(\"Explained Variance Ratio\")\nst.write(pca.explained_variance_ratio_)\n\n# Scatter Plot using Plotly Express\nfig = px.scatter(finalDf, x='PCA1', y='PCA2', color='Species',\n                 title='PCA of Iris Dataset',\n                 labels={'PCA1': 'Principal Component 1', 'PCA2': 'Principal Component 2'},\n                 color_discrete_sequence=px.colors.qualitative.Dark24)\n\nst.plotly_chart(fig, use_container_width=True)",
    "title": "Iris Dataset: PCA Visualization",
    "description": "",
    "tags": [],
    "used_csv": "iris.csv"
  },
  "cd92d301-0c25-4c26-b2f5-3f3a255d1919": {
    "id": "cd92d301-0c25-4c26-b2f5-3f3a255d1919",
    "created_at": "2025-04-09T19:47:41.655440",
    "updated_at": "2025-04-09T19:50:07.148126",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n#st.set_option('deprecation.showPyplotGlobalUse', False)\n\nst.title(\"Image Convolution App\")\n\nuploaded_file = st.file_uploader(\"Choose an image...\", type=[\"jpg\", \"jpeg\", \"png\"])\n\nif uploaded_file is not None:\n    # Load the image\n    try:\n        image = plt.imread(uploaded_file)\n    except Exception as e:\n        st.error(f\"Error loading image: {e}\")\n        st.stop()\n\n    st.subheader(\"Original Image\")\n    st.image(image, caption=\"Uploaded Image\", use_container_width=True)\n\n    # Convert to grayscale\n    gray_image = np.dot(image[...,:3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)\n    st.subheader(\"Grayscale Image\")\n    st.image(gray_image, caption=\"Grayscale Image\", use_container_width=True)\n\n    # Define common kernels\n    kernels = {\n        \"Identity\": np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]]),\n        \"Sharpen\": np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]]),\n        \"Edge Detection\": np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]),\n        \"Box Blur\": (1/9) * np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]]),\n        \"Gaussian Blur\": (1/16) * np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]])\n    }\n\n    kernel_names = list(kernels.keys())\n\n    # Kernel selection\n    selected_kernel_name = st.selectbox(\"Select a Predefined Kernel\", kernel_names)\n\n    # Manual kernel input\n    st.subheader(\"Or Input Custom Kernel (3x3)\")\n    col1, col2, col3 = st.columns(3)\n    k11 = col1.number_input(\"k11\", value=0.0, format=\"%.2f\")\n    k12 = col2.number_input(\"k12\", value=0.0, format=\"%.2f\")\n    k13 = col3.number_input(\"k13\", value=0.0, format=\"%.2f\")\n    \n    col4, col5, col6 = st.columns(3)\n    k21 = col4.number_input(\"k21\", value=0.0, format=\"%.2f\")\n    k22 = col5.number_input(\"k22\", value=0.0, format=\"%.2f\")\n    k23 = col6.number_input(\"k23\", value=0.0, format=\"%.2f\")\n\n    col7, col8, col9 = st.columns(3)\n    k31 = col7.number_input(\"k31\", value=0.0, format=\"%.2f\")\n    k32 = col8.number_input(\"k32\", value=0.0, format=\"%.2f\")\n    k33 = col9.number_input(\"k33\", value=0.0, format=\"%.2f\")\n\n    custom_kernel = np.array([[k11, k12, k13], [k21, k22, k23], [k31, k32, k33]])\n\n    use_custom_kernel = st.checkbox(\"Use custom kernel?\")\n\n    if use_custom_kernel:\n        selected_kernel = custom_kernel\n        selected_kernel_name = \"Custom Kernel\"\n    else:\n        selected_kernel = kernels[selected_kernel_name]\n    \n    st.write(f\"Selected Kernel: {selected_kernel_name}\")\n    st.write(selected_kernel)\n\n\n    # Convolution operation (simplified for demonstration)\n    def convolve(image, kernel):\n        kernel_size = kernel.shape[0]\n        padding = kernel_size // 2\n        padded_image = np.pad(image, padding, mode='constant')\n        output_image = np.zeros_like(image, dtype=np.float64)\n\n        for x in range(image.shape[0]):\n            for y in range(image.shape[1]):\n                output_image[x, y] = np.sum(padded_image[x:x+kernel_size, y:y+kernel_size] * kernel)\n        \n        output_image = np.clip(output_image, 0, 255).astype(np.uint8)\n\n        return output_image\n\n    # Apply convolution\n    convolved_image = convolve(gray_image, selected_kernel)\n\n    # Display convolved image\n    st.subheader(\"Convolved Image\")\n    st.image(convolved_image, caption=f\"Convolved Image with {selected_kernel_name}\", use_container_width=True)",
    "title": "Image Convolution Explorer",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "fe686074-aed2-4c62-bb64-d692e234861b": {
    "id": "fe686074-aed2-4c62-bb64-d692e234861b",
    "created_at": "2025-04-17T13:45:54.995326",
    "updated_at": "2025-04-17T13:46:22.984606",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Aluminosilicate Phase Diagram\")\n\nst.markdown(\"\"\"\n    This interactive visualization explores the stability fields of andalusite, kyanite, and sillimanite \n    (Al<sub>2</sub>SiO<sub>5</sub> polymorphs) as a function of pressure and temperature. \n    These minerals are important indicators of metamorphic conditions in rocks.  \n    By understanding which mineral is stable at a given pressure and temperature, \n    geologists can infer the conditions under which a rock formed.\n    \"\"\")\n\n# Thermodynamic data (example - needs real data for accuracy!)\n# These values are placeholders.  Real thermodynamic data would be required for accurate representation.\nandalusite_G = lambda T, P, a_Al2O3, a_SiO2: 100000 + 0.08 * (T - 273.15) - 0.001 * P - np.log(a_Al2O3) - np.log(a_SiO2) # Gibbs Free Energy (arbitrary units)\nkyanite_G = lambda T, P, a_Al2O3, a_SiO2: 100050 + 0.07 * (T - 273.15) - 0.0012 * P - np.log(a_Al2O3) - np.log(a_SiO2)\nsillimanite_G = lambda T, P, a_Al2O3, a_SiO2: 100020 + 0.075 * (T - 273.15) - 0.0011 * P - np.log(a_Al2O3) - np.log(a_SiO2)\n\n# Define the grid of P-T conditions\nT = np.linspace(200, 800, 50) + 273.15 # Temperature in Celsius, converted to Kelvin\nP = np.linspace(0, 10, 50) * 1000  # Pressure in kbar, converted to bar (approximated)\n\n# Create a meshgrid\nT_grid, P_grid = np.meshgrid(T, P)\n\n# Interactive sliders for activities\na_Al2O3 = st.slider(\"Activity of Al2O3\", min_value=0.5, max_value=1.0, value=1.0, step=0.01)\na_SiO2 = st.slider(\"Activity of SiO2\", min_value=0.5, max_value=1.0, value=1.0, step=0.01)\n\n# Calculate Gibbs Free Energies for each mineral at each P-T point\nandalusite_G_values = andalusite_G(T_grid, P_grid, a_Al2O3, a_SiO2)\nkyanite_G_values = kyanite_G(T_grid, P_grid, a_Al2O3, a_SiO2)\nsillimanite_G_values = sillimanite_G(T_grid, P_grid, a_Al2O3, a_SiO2)\n\n# Determine the stable mineral at each P-T point\nstable_mineral = np.argmin([andalusite_G_values, kyanite_G_values, sillimanite_G_values], axis=0)\n\n# Create a DataFrame for easier plotting\ndf = pd.DataFrame({\n    'Temperature': T_grid.flatten() - 273.15,  # Convert back to Celsius\n    'Pressure': P_grid.flatten() / 1000,    # Convert back to kbar\n    'Stable Mineral': stable_mineral.flatten()\n})\n\n# Assign mineral names based on the index\nmineral_names = {0: 'Andalusite', 1: 'Kyanite', 2: 'Sillimanite'}\ndf['Mineral Name'] = df['Stable Mineral'].map(mineral_names)\n\n# 3D Scatter Plot\nfig = px.scatter_3d(df, x='Temperature', y='Pressure', z='Stable Mineral',\n                    color='Mineral Name',\n                    color_discrete_map={'Andalusite': 'red', 'Kyanite': 'blue', 'Sillimanite': 'green'},\n                    labels={'Temperature': 'Temperature (\u00b0C)', 'Pressure': 'Pressure (kbar)', 'Stable Mineral': 'Mineral'},\n                    title='Aluminosilicate Phase Diagram',\n                    hover_data=['Mineral Name'],\n                    )\n\nfig.update_layout(\n    scene=dict(\n        zaxis=dict(\n            tickvals=[0, 1, 2],\n            ticktext=['Andalusite', 'Kyanite', 'Sillimanite'],\n            title = \"Mineral\"\n        ),\n        xaxis_title='Temperature (\u00b0C)',\n        yaxis_title='Pressure (kbar)'\n    )\n)\nst.plotly_chart(fig, use_container_width=True)\n\n# 2D Slice at Selected Pressure/Temperature\nslice_type = st.radio(\"Select Slice Type:\", (\"Pressure\", \"Temperature\"))\n\nif slice_type == \"Pressure\":\n    pressure_slice = st.slider(\"Pressure for 2D Slice (kbar)\", min_value=0.0, max_value=10.0, value=5.0, step=0.1)\n    # Find the nearest pressure value in the grid\n    nearest_pressure_index = np.argmin(np.abs(P / 1000 - pressure_slice)) # P is in bar, convert to kbar\n    \n    # Extract the stable minerals and temperature for the slice\n    slice_data = df[df['Pressure'] == P[nearest_pressure_index]/1000]\n    \n    # Create a 2D plot\n    fig_2d = px.scatter(slice_data, x='Temperature', y='Mineral Name', color='Mineral Name',\n                        color_discrete_map={'Andalusite': 'red', 'Kyanite': 'blue', 'Sillimanite': 'green'},\n                        title=f'Aluminosilicate Phase Diagram at {pressure_slice:.1f} kbar')\n    fig_2d.update_layout(yaxis={'categoryorder':'array', 'categoryarray':['Andalusite', 'Kyanite', 'Sillimanite']})\n    st.plotly_chart(fig_2d, use_container_width=True)\n\nelif slice_type == \"Temperature\":\n    temperature_slice = st.slider(\"Temperature for 2D Slice (\u00b0C)\", min_value=200.0, max_value=800.0, value=500.0, step=10.0)\n    # Find the nearest temperature value in the grid\n    nearest_temperature_index = np.argmin(np.abs(T - 273.15 - temperature_slice)) # T is in Kelvin, convert to C\n    \n    # Extract the stable minerals and pressure for the slice\n    slice_data = df[df['Temperature'] == T[nearest_temperature_index] - 273.15]\n    \n    # Create a 2D plot\n    fig_2d = px.scatter(slice_data, x='Pressure', y='Mineral Name', color='Mineral Name',\n                        color_discrete_map={'Andalusite': 'red', 'Kyanite': 'blue', 'Sillimanite': 'green'},\n                        title=f'Aluminosilicate Phase Diagram at {temperature_slice:.1f} \u00b0C')\n    fig_2d.update_layout(yaxis={'categoryorder':'array', 'categoryarray':['Andalusite', 'Kyanite', 'Sillimanite']})\n    st.plotly_chart(fig_2d, use_container_width=True)",
    "title": "Interactive Aluminosilicate Phase Diagram Visualization",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "f8093968-16c0-4e44-b3c6-68f1ecf39922": {
    "id": "f8093968-16c0-4e44-b3c6-68f1ecf39922",
    "created_at": "2025-04-17T13:47:54.562850",
    "updated_at": "2025-04-17T13:48:05.271171",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n# --- Title and Introduction ---\nst.title(\"Aluminosilicate Phase Diagram\")\nst.write(\"This interactive diagram shows the stability fields of andalusite, kyanite, and sillimanite under different temperature and pressure conditions. These minerals are polymorphs of Al2SiO5 and are important indicators of metamorphic conditions.\")\n\n# --- Define Data for Stability Fields ---\n# Approximate coordinates for the stability fields (simplified for demonstration)\n# These are not precise thermodynamic calculations, but illustrative.\n\ntemp = np.linspace(200, 800, 100)  # Temperature in Celsius\npressure = np.linspace(0, 8, 100)  # Pressure in kbar\nT, P = np.meshgrid(temp, pressure)\n\n# Define fields based on simplified linear relationships\n# NOTE: These are NOT accurate thermodynamic calculations, but estimations to demonstrate plotting.\nandalusite = (P < 0.007 * T - 1.4) & (P > 0)\nkyanite = (P > 0.007 * T - 1.4) & (P > 0.012 * T - 1.6)\nsillimanite = (P > 0) & (P < 8) & (P > 0.012 * T - 1.6)\nno_mineral = ~(andalusite | kyanite | sillimanite) # Added a \"no mineral\" area to prevent plotting issues\n\n# --- Create the Plot ---\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the stability fields with different colors\ncontour_andalusite = ax.contourf(T, P, andalusite, levels=[0, 0.5, 1], colors=['coral'], alpha=0.5)\ncontour_kyanite = ax.contourf(T, P, kyanite, levels=[0, 0.5, 1], colors=['skyblue'], alpha=0.5)\ncontour_sillimanite = ax.contourf(T, P, sillimanite, levels=[0, 0.5, 1], colors=['lightgreen'], alpha=0.5)\nax.contourf(T, P, no_mineral, levels=[0, 0.5, 1], colors=['lightgrey'], alpha=0.5) # Plot the no mineral area\n\n\n# Plot the reaction boundaries as lines (simplified)\nax.plot(temp, 0.007 * temp - 1.4, 'k--', label='Andalusite/Kyanite')\nax.plot(temp, 0.012 * temp - 1.6, 'k:', label='Kyanite/Sillimanite')\n\n\n# Mark the triple point (approximate)\nax.plot(500, 4.5, 'ro', markersize=8, label='Triple Point')\nax.text(510, 4.5, 'Triple Point', color='red')\n\n# Add labels and title\nax.set_xlabel('Temperature (\u00b0C)')\nax.set_ylabel('Pressure (kbar)')\nax.set_title('Al2SiO5 Phase Diagram')\n\n# Set axis limits\nax.set_xlim(200, 800)\nax.set_ylim(0, 8)\n\n# Add legend\nhandles, labels = ax.get_legend_handles_labels()\nax.legend(handles, labels, loc='upper right')\n\n# Add grid\nax.grid(True)\n\n# --- Display Plot in Streamlit ---\nst.pyplot(fig, use_container_width=True)\n\n# --- Add Geological Significance Explanation ---\nst.subheader(\"Geological Significance\")\nst.write(\"This diagram is a powerful tool in metamorphic petrology. By analyzing the presence of andalusite, kyanite, or sillimanite in a metamorphic rock, geologists can estimate the temperature and pressure conditions under which the rock formed. The triple point represents the specific conditions where all three minerals can coexist in equilibrium, providing a precise constraint on the metamorphic environment.\")\n\nst.write(\"The placement of the reaction boundaries are estimates and can vary based on the specific composition of the rocks and the presence of other fluids.\")",
    "title": "Al2SiO5 Phase Diagram: Stability of Polymorphs",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "c7edb89e-21bb-4867-9d32-29d0697305b4": {
    "id": "c7edb89e-21bb-4867-9d32-29d0697305b4",
    "created_at": "2025-04-17T13:50:07.200119",
    "updated_at": "2025-04-17T13:50:24.755470",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.set_page_config(layout=\"wide\")\n\n# Define the vertices of the ternary diagram\nQ = (0, 0)  # Quartz\nA = (1, 0)  # Alkali Feldspar\nP = (0.5, np.sqrt(3)/2)  # Plagioclase\n\n# Define the classification boundaries (approximate)\n# These are simplified for demonstration and may not be perfectly accurate.\n# The coordinates are in terms of fractional distances along the triangle edges.\n# QAP classification adapted from Streckeisen, 1974\nclassification_regions = {\n    \"Granite\": [(0.9, 0), (0.6, 0.4), (0.6, 0.05), (0.9, 0)], #modified\n    \"Granodiorite\": [(0.6, 0.4), (0.2, 0.65), (0.2, 0.15), (0.6, 0.05)],#modified\n    \"Tonalite\": [(0.2, 0.65), (0.0, 0.85), (0.0, 0.35), (0.2, 0.15)], #modified\n    \"Syenite\": [(0.9, 0), (0.95, 0.05), (1.0,0.0), (0.9,0.0)], #modified\n    \"Monzonite\": [(0.6, 0.05), (0.55, 0.0), (0.95, 0.05), (0.6, 0.05)], #modified\n    \"Diorite\": [(0.2, 0.15), (0.0, 0.35), (0.0, 0.0), (0.2, 0.15)], #modified\n    \"Quartz-rich Granite\": [(0.9,0.0),(1.0,0.0),(0.95,0.05),(0.9,0.0)],\n    \"Quartz-rich Granodiorite\": [(0.55, 0.0), (0.6, 0.05), (0.2, 0.15), (0.0,0.0)]\n}\n\n\n# Function to convert QAP percentages to Cartesian coordinates\ndef qap_to_xy(q, a, p):\n    \"\"\"Converts QAP percentages to Cartesian coordinates within the triangle.\"\"\"\n    x = a + 0.5 * q\n    y = np.sqrt(3)/2 * q\n    return x, y\n\n# Sample data (QAP percentages)\nif 'sample_data' not in st.session_state:\n    st.session_state['sample_data'] = pd.DataFrame({\n        \"Rock\": [\"Sample 1\", \"Sample 2\", \"Sample 3\", \"Sample 4\", \"Sample 5\"],\n        \"Quartz\": [65, 55, 15, 5, 2],\n        \"Alkali Feldspar\": [25, 15, 40, 80, 20],\n        \"Plagioclase\": [10, 30, 45, 15, 78]\n    })\n\n    # Normalize the percentages to ensure they sum to 100\n    st.session_state['sample_data'][[\"Quartz\", \"Alkali Feldspar\", \"Plagioclase\"]] = st.session_state['sample_data'][[\"Quartz\", \"Alkali Feldspar\", \"Plagioclase\"]].apply(lambda x: x/x.sum()*100, axis=1)\n\n    # Convert QAP percentages to x, y coordinates\n    st.session_state['sample_data'][\"x\"], st.session_state['sample_data'][\"y\"] = zip(*st.session_state['sample_data'].apply(lambda row: qap_to_xy(row[\"Quartz\"]/100, row[\"Alkali Feldspar\"]/100, row[\"Plagioclase\"]/100), axis=1))\n\n# --- Streamlit App ---\nst.title(\"QAP Ternary Diagram for Plutonic Rock Classification\")\nst.markdown(\"This interactive diagram allows you to plot rock compositions and classify them based on their Quartz (Q), Alkali Feldspar (A), and Plagioclase (P) content.\")\n\n# Sidebar for user input\nst.sidebar.header(\"Add New Sample\")\nquartz_input = st.sidebar.slider(\"Quartz (%)\", 0, 100, 25)\nalkali_feldspar_input = st.sidebar.slider(\"Alkali Feldspar (%)\", 0, 100, 25)\nplagioclase_input = st.sidebar.slider(\"Plagioclase (%)\", 0, 100, 50)\n\n# Normalize input values\ntotal = quartz_input + alkali_feldspar_input + plagioclase_input\nif total > 0:\n    quartz_input = quartz_input / total * 100\n    alkali_feldspar_input = alkali_feldspar_input / total * 100\n    plagioclase_input = plagioclase_input / total * 100\nelse:\n    st.sidebar.warning(\"Sum of percentages must be greater than 0.\")\n\nnew_sample_name = st.sidebar.text_input(\"New Sample Name\", \"New Sample\")\n\nif st.sidebar.button(\"Add Sample\"):\n    new_x, new_y = qap_to_xy(quartz_input/100, alkali_feldspar_input/100, plagioclase_input/100)\n    new_row = pd.DataFrame({\"Rock\": [new_sample_name],\n                            \"Quartz\": [quartz_input],\n                            \"Alkali Feldspar\": [alkali_feldspar_input],\n                            \"Plagioclase\": [plagioclase_input],\n                            \"x\": [new_x],\n                            \"y\": [new_y]})\n    st.session_state['sample_data'] = pd.concat([st.session_state['sample_data'], new_row], ignore_index=True)\n\n\n# Create the plot using Plotly\nfig = go.Figure()\n\n# Add the classification regions\ncolors = [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\"]\ni=0\nfor rock_type, vertices in classification_regions.items():\n    x = [Q[0] + (A[0]-Q[0])*v[0] + (P[0]-Q[0])*v[1] for v in vertices]\n    y = [Q[1] + (A[1]-Q[1])*v[0] + (P[1]-Q[1])*v[1] for v in vertices]\n\n    fig.add_trace(go.Scatter(x=x, y=y, fill=\"toself\", mode=\"lines\", name=rock_type, fillcolor=colors[i % len(colors)], line=dict(width=0.5), opacity=0.5))\n    i+=1\n\n# Add the sample data points\nfig.add_trace(go.Scatter(x=st.session_state['sample_data'][\"x\"], y=st.session_state['sample_data'][\"y\"], mode=\"markers\", marker=dict(size=10, color=\"black\"), text=st.session_state['sample_data'][\"Rock\"], name=\"Samples\"))\n\n# Add the triangle outline\nfig.add_trace(go.Scatter(x=[Q[0], A[0], P[0], Q[0]], y=[Q[1], A[1], P[1], Q[1]], mode=\"lines\", line=dict(color=\"black\")))\n\n# Add the vertex labels\nfig.add_annotation(x=Q[0]-0.05, y=Q[1]-0.02, text=\"Q\", showarrow=False, font=dict(size=16))\nfig.add_annotation(x=A[0]+0.05, y=A[1]-0.02, text=\"A\", showarrow=False, font=dict(size=16))\nfig.add_annotation(x=P[0], y=P[1]+0.05, text=\"P\", showarrow=False, font=dict(size=16))\n\n# Customize the layout\nfig.update_layout(\n    title=\"QAP Ternary Diagram for Plutonic Rock Classification\",\n    xaxis=dict(range=[-0.1, 1.1], visible=False, fixedrange=True),\n    yaxis=dict(range=[-0.1, 1.0], visible=False, fixedrange=True),\n    showlegend=True,\n    width=800,\n    height=700,\n    margin=dict(l=0, r=0, b=0, t=50),\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)'\n)\n\n# Show the plot in Streamlit\nst.plotly_chart(fig, use_container_width=True)\n\n# Display the sample data as a table\nst.subheader(\"Sample Data\")\nst.dataframe(st.session_state['sample_data'])",
    "title": "Plutonic Rock Classification: QAP Ternary Diagram",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "f2929a9d-6845-4a6f-9959-32a1532989bf": {
    "id": "f2929a9d-6845-4a6f-9959-32a1532989bf",
    "created_at": "2025-04-17T13:51:27.494409",
    "updated_at": "2025-04-17T13:53:21.268355",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Suppress warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# QAP Ternary Diagram for Plutonic Rock Classification\n\n# Define rock type regions more accurately based on Streckeisen classification\ndef add_rock_type_regions(fig):\n    # Granite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [10, 35, 65, 90, 90],\n        'b': [10, 10, 10, 10, 0],\n        'c': [80, 55, 25, 0, 10],\n        'text': ['', '', 'Granite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Granite',\n        'line': {'color': 'rgba(255, 0, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(255, 0, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Granodiorite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [10, 10, 35, 10],\n        'b': [40, 10, 10, 40],\n        'c': [50, 80, 55, 50],\n        'text': ['', '', 'Granodiorite', ''],\n        'textposition': 'middle center',\n        'name': 'Granodiorite',\n        'line': {'color': 'rgba(0, 255, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(0, 255, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Tonalite (Quartz Diorite)\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [10, 10, 0, 0, 10],\n        'b': [65, 40, 40, 65, 65],\n        'c': [25, 50, 60, 35, 25],\n        'text': ['', '', 'Tonalite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Tonalite',\n        'line': {'color': 'rgba(0, 0, 255, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(0, 0, 255, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Syenite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [65, 90, 90, 65, 65],\n        'b': [35, 10, 0, 0, 35],\n        'c': [0, 0, 10, 35, 0],\n        'text': ['', '', 'Syenite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Syenite',\n        'line': {'color': 'rgba(255, 255, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(255, 255, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Monzonite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [35, 65, 65, 35, 35],\n        'b': [65, 35, 0, 0, 65],\n        'c': [0, 0, 35, 65, 0],\n        'text': ['', '', 'Monzonite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Monzonite',\n        'line': {'color': 'rgba(255, 0, 255, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(255, 0, 255, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Diorite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [0, 35, 35, 0, 0],\n        'b': [100, 65, 0, 0, 100],\n        'c': [0, 0, 65, 100, 0],\n        'text': ['', '', 'Diorite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Diorite',\n        'line': {'color': 'rgba(0, 255, 255, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(0, 255, 255, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Quartz Monzonite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [35, 65, 65, 35, 35],\n        'b': [10, 10, 0, 0, 10],\n        'c': [55, 25, 35, 65, 55],\n        'text': ['', '', 'Quartz<br>Monzonite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Quartz Monzonite',\n        'line': {'color': 'rgba(128, 128, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(128, 128, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    return fig\n\n# Sample Data (QAP values as percentages)\nsample_data = pd.DataFrame({\n    'Rock Name': ['Granite', 'Granodiorite', 'Tonalite', 'Syenite', 'Monzonite', 'Diorite', 'Quartz Monzonite', 'Quartz Diorite'],\n    'Q': [30, 20, 10, 5, 5, 0, 20, 15],\n    'A': [30, 20, 10, 60, 30, 10, 20, 5],\n    'P': [40, 60, 80, 35, 65, 90, 60, 80]\n})\n\n# Normalize to ensure Q+A+P = 100 for each row\nfor index, row in sample_data.iterrows():\n    total = row['Q'] + row['A'] + row['P']\n    sample_data.loc[index, 'Q'] = (row['Q'] / total) * 100\n    sample_data.loc[index, 'A'] = (row['A'] / total) * 100\n    sample_data.loc[index, 'P'] = (row['P'] / total) * 100\n\n# Main content\nst.title(\"QAP Ternary Diagram for Plutonic Rock Classification\")\nst.write(\"This diagram is based on the Streckeisen classification for plutonic igneous rocks.\")\n\n# User input for new data points\nst.sidebar.header(\"Add Sample Data\")\nnew_rock_name = st.sidebar.text_input(\"Rock Name\", \"New Rock\")\nnew_q = st.sidebar.number_input(\"Quartz (%)\", min_value=0.0, max_value=100.0, value=25.0, step=0.1)\nnew_a = st.sidebar.number_input(\"Alkali Feldspar (%)\", min_value=0.0, max_value=100.0, value=25.0, step=0.1)\nnew_p = st.sidebar.number_input(\"Plagioclase (%)\", min_value=0.0, max_value=100.0, value=50.0, step=0.1)\n\n# Calculate total to show user\ntotal = new_q + new_a + new_p\nst.sidebar.write(f\"Total: {total:.1f}% (will be normalized to 100%)\")\n\nif st.sidebar.button(\"Add Rock\"):\n    # Normalize to 100%\n    total = new_q + new_a + new_p\n    new_q = (new_q / total) * 100\n    new_a = (new_a / total) * 100\n    new_p = (new_p / total) * 100\n    \n    # Add to dataframe\n    new_row = pd.DataFrame({'Rock Name': [new_rock_name], 'Q': [new_q], 'A': [new_a], 'P': [new_p]})\n    sample_data = pd.concat([sample_data, new_row], ignore_index=True)\n    st.rerun()\n\n# Color options\nst.sidebar.header(\"Plot Options\")\nuse_rock_type_regions = st.sidebar.checkbox(\"Show Rock Type Fields\", value=True)\nshow_legend = st.sidebar.checkbox(\"Show Legend\", value=True)\n\n# Create ternary plot\nfig = go.Figure()\n\n# Add rock type regions if selected\nif use_rock_type_regions:\n    fig = add_rock_type_regions(fig)\n\n# Add data points\nfig.add_trace(go.Scatterternary({\n    'mode': 'markers+text',\n    'a': sample_data['A'],\n    'b': sample_data['P'], \n    'c': sample_data['Q'],\n    'text': sample_data['Rock Name'],\n    'name': 'Samples',\n    'marker': {\n        'symbol': 'circle',\n        'size': 10,\n        'color': 'black',\n        'line': {'width': 1, 'color': 'white'}\n    },\n    'textposition': 'top center'\n}))\n\n# Configure ternary axes\nfig.update_layout({\n    'ternary': {\n        'sum': 100,\n        'aaxis': {'title': 'Alkali Feldspar (A)', 'min': 0, 'linewidth': 2, 'ticksuffix': '%', 'tickfont': {'size': 12}},\n        'baxis': {'title': 'Plagioclase (P)', 'min': 0, 'linewidth': 2, 'ticksuffix': '%', 'tickfont': {'size': 12}},\n        'caxis': {'title': 'Quartz (Q)', 'min': 0, 'linewidth': 2, 'ticksuffix': '%', 'tickfont': {'size': 12}}\n    },\n    'showlegend': show_legend,\n    'height': 700,\n    'width': 800,\n    'margin': {'l': 50, 'r': 50, 'b': 50, 't': 50}\n})\n\n# Display the ternary plot\nst.plotly_chart(fig, use_container_width=True)\n\n# Add explanation\nst.subheader(\"About QAP Diagrams\")\nst.write(\"\"\"\nThe QAP diagram is a ternary plot used by geologists to classify plutonic igneous rocks based on their mineral composition. \nThe three vertices represent:\n- **Q**: Quartz\n- **A**: Alkali feldspar (orthoclase, microcline, etc.)\n- **P**: Plagioclase feldspar\n\nThis classification system, developed by Albert Streckeisen, is widely used in petrography and igneous petrology.\n\"\"\")\n\n# Display the sample data table with formatting\nst.subheader(\"Sample Data Table\")\nst.dataframe(sample_data.style.format({'Q': '{:.1f}%', 'A': '{:.1f}%', 'P': '{:.1f}%'}), hide_index=True)\n\n# Add download option for the data\ncsv = sample_data.to_csv(index=False)\nst.download_button(\n    label=\"Download Data as CSV\",\n    data=csv,\n    file_name=\"qap_data.csv\",\n    mime=\"text/csv\"\n)",
    "title": "Plutonic Rock Classification: QAP Ternary Diagram",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "8c9889f2-db78-4543-8647-8f94c36b6262": {
    "id": "8c9889f2-db78-4543-8647-8f94c36b6262",
    "created_at": "2025-04-17T13:58:45.709628",
    "updated_at": "2025-04-17T13:59:04.447962",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Interactive Piper Diagram for Hydrogeochemical Analysis\")\n\n# Explanation of Piper Diagram\nst.markdown(\"\"\"\n## Understanding Piper Diagrams\n\nPiper diagrams are graphical representations used in hydrogeochemistry to visualize and classify water samples based on their major ion chemistry. They consist of three main components:\n\n*   **Cation Triangle:** Represents the relative proportions of major cations (Ca\u00b2\u207a, Mg\u00b2\u207a, Na\u207a+K\u207a).\n*   **Anion Triangle:** Represents the relative proportions of major anions (HCO\u2083\u207b+CO\u2083\u00b2\u207b, SO\u2084\u00b2\u207b, Cl\u207b).\n*   **Central Diamond:** Projects the data from the two triangles to show overall water type.\n\nThe position of a sample within these plots provides insights into its geochemical characteristics and origin. Different regions of the diamond plot correspond to different water types (e.g., Ca-HCO\u2083, Na-Cl).\n\nThis tool allows you to interactively explore Piper diagrams and classify water samples based on their ion concentrations. You can input your own data and visualize how it compares to common water types.\n\"\"\")\n\n# Sample Data\nsample_data = {\n    'Sample': ['Freshwater 1', 'Freshwater 2', 'Seawater', 'Brine', 'Groundwater 1', 'Groundwater 2'],\n    'Ca': [1.5, 2.0, 0.4, 0.1, 1.8, 0.5],\n    'Mg': [0.5, 0.8, 0.1, 0.05, 0.7, 0.2],\n    'Na': [0.3, 0.5, 4.7, 6.0, 0.4, 5.0],\n    'K': [0.1, 0.05, 0.1, 0.2, 0.05, 0.1],\n    'HCO3': [2.5, 3.0, 0.1, 0.05, 2.8, 0.3],\n    'SO4': [0.4, 0.6, 0.3, 1.5, 0.5, 2.0],\n    'Cl': [0.2, 0.3, 5.5, 7.0, 0.3, 6.0],\n    'Water Type': ['Freshwater', 'Freshwater', 'Seawater', 'Brine', 'Freshwater', 'Brine']\n}\ndf = pd.DataFrame(sample_data)\n\n# Sidebar for User Input\nst.sidebar.header(\"Input New Water Sample\")\nnew_sample_name = st.sidebar.text_input(\"Sample Name\", \"New Sample\")\nnew_ca = st.sidebar.number_input(\"Ca\u00b2\u207a (meq/L)\", value=1.0)\nnew_mg = st.sidebar.number_input(\"Mg\u00b2\u207a (meq/L)\", value=0.5)\nnew_na = st.sidebar.number_input(\"Na\u207a (meq/L)\", value=0.3)\nnew_k = st.sidebar.number_input(\"K\u207a (meq/L)\", value=0.1)\nnew_hco3 = st.sidebar.number_input(\"HCO\u2083\u207b (meq/L)\", value=2.5)\nnew_so4 = st.sidebar.number_input(\"SO\u2084\u00b2\u207b (meq/L)\", value=0.4)\nnew_cl = st.sidebar.number_input(\"Cl\u207b (meq/L)\", value=0.2)\nnew_water_type = st.sidebar.text_input(\"Water Type\", \"User Defined\")\n\nif st.sidebar.button(\"Add Sample\"):\n    new_row = {\n        'Sample': new_sample_name,\n        'Ca': new_ca,\n        'Mg': new_mg,\n        'Na': new_na,\n        'K': new_k,\n        'HCO3': new_hco3,\n        'SO4': new_so4,\n        'Cl': new_cl,\n        'Water Type': new_water_type\n    }\n    df = pd.concat([df, pd.DataFrame(new_row, index=[0])], ignore_index=True)\n    st.rerun()\n\n# Normalization function\ndef normalize_ions(row):\n    cations_sum = row['Ca'] + row['Mg'] + row['Na'] + row['K']\n    anions_sum = row['HCO3'] + row['SO4'] + row['Cl']\n\n    row['Ca_percent'] = (row['Ca'] / cations_sum) * 100\n    row['Mg_percent'] = (row['Mg'] / cations_sum) * 100\n    row['NaK_percent'] = ((row['Na'] + row['K']) / cations_sum) * 100\n\n    row['HCO3_percent'] = (row['HCO3'] / anions_sum) * 100\n    row['SO4_percent'] = (row['SO4'] / anions_sum) * 100\n    row['Cl_percent'] = (row['Cl'] / anions_sum) * 100\n    return row\n\ndf = df.apply(normalize_ions, axis=1)\n\n# Cation Triangle Data\ncation_data = df[['Sample', 'Ca_percent', 'Mg_percent', 'NaK_percent', 'Water Type']]\ncation_data = cation_data.rename(columns={'Ca_percent': 'Ca', 'Mg_percent': 'Mg', 'NaK_percent': 'NaK'})\n\n# Anion Triangle Data\nanion_data = df[['Sample', 'HCO3_percent', 'SO4_percent', 'Cl_percent', 'Water Type']]\nanion_data = anion_data.rename(columns={'HCO3_percent': 'HCO3', 'SO4_percent': 'SO4', 'Cl_percent': 'Cl'})\n\n# Diamond Data (Piper Plot) - Simplified calculation\ndf['CaNa'] = df['Ca_percent'] - df['NaK_percent']\ndf['MgK'] = df['Mg_percent'] - df['NaK_percent']\ndf['HCO3Cl'] = df['HCO3_percent'] - df['Cl_percent']\ndf['SO4Cl'] = df['SO4_percent'] - df['Cl_percent']\n\ndf['diamond_x'] = (df['CaNa'] + df['HCO3Cl']) / 2\ndf['diamond_y'] = (df['MgK'] + df['SO4Cl']) / 2 * (np.sqrt(3)/2)\n\n# Water Type Filtering\nwater_type_options = df['Water Type'].unique().tolist()\nselected_water_types = st.multiselect(\"Select Water Types to Display\", water_type_options, default=water_type_options)\nfiltered_df = df[df['Water Type'].isin(selected_water_types)]\n\n# Create Piper Diagram using Plotly\nfig = go.Figure()\n\n# Cation Triangle\nfig.add_trace(go.Scatter(\n    x=filtered_df['Ca_percent'],\n    y=filtered_df['Mg_percent'],\n    mode='markers',\n    marker=dict(size=10, color=filtered_df['Water Type'], line=dict(width=0.5, color='Black')),\n    name='Cations',\n    text=[f\"Sample: {row['Sample']}<br>Ca: {row['Ca_percent']:.2f}%<br>Mg: {row['Mg_percent']:.2f}%<br>Na+K: {row['NaK_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\"\n))\n\n# Anion Triangle\nfig.add_trace(go.Scatter(\n    x=[x + 100 for x in filtered_df['HCO3_percent']],\n    y=filtered_df['SO4_percent'],\n    mode='markers',\n    marker=dict(size=10, color=filtered_df['Water Type'], line=dict(width=0.5, color='Black')),\n    name='Anions',\n    text=[f\"Sample: {row['Sample']}<br>HCO3: {row['HCO3_percent']:.2f}%<br>SO4: {row['SO4_percent']:.2f}%<br>Cl: {row['Cl_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\"\n))\n\n# Diamond Plot\nfig.add_trace(go.Scatter(\n    x=[x + 50 for x in filtered_df['diamond_x']],\n    y=filtered_df['diamond_y'],\n    mode='markers',\n    marker=dict(size=10, color=filtered_df['Water Type'], line=dict(width=0.5, color='Black')),\n    name='Diamond',\n    text=[f\"Sample: {row['Sample']}<br>Diamond X: {row['diamond_x']:.2f}<br>Diamond Y: {row['diamond_y']:.2f}\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\"\n))\n\n# Layout\nfig.update_layout(\n    title='Piper Diagram',\n    xaxis=dict(range=[-10, 210], showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(range=[-10, 100], showgrid=False, zeroline=False, showticklabels=False),\n    shapes=[\n        # Cation Triangle\n        dict(type=\"line\", x0=0, y0=0, x1=50, y1=86.6, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=50, y0=86.6, x1=100, y0=0, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=0, y0=0, x1=100, y0=0, line=dict(color=\"Black\", width=1)),\n        # Anion Triangle\n        dict(type=\"line\", x0=100, y0=0, x1=150, y1=86.6, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=150, y0=86.6, x1=200, y0=0, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=100, y0=0, x1=200, y0=0, line=dict(color=\"Black\", width=1)),\n        # Diamond\n        dict(type=\"line\", x0=50, y0=86.6, x1=150, y1=86.6, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=50, y0=86.6, x1=100, y0=0, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=150, y0=86.6, x1=100, y0=0, line=dict(color=\"Black\", width=1))\n    ],\n    annotations=[\n        # Cation Triangle Labels\n        dict(x=50, y=90, text='Mg\u00b2\u207a', showarrow=False),\n        dict(x=0, y=-5, text='Ca\u00b2\u207a', showarrow=False),\n        dict(x=100, y=-5, text='Na\u207a+K\u207a', showarrow=False),\n        # Anion Triangle Labels\n        dict(x=150, y=90, text='SO\u2084\u00b2\u207b', showarrow=False),\n        dict(x=100, y=-5, text='HCO\u2083\u207b+CO\u2083\u00b2\u207b', showarrow=False),\n        dict(x=200, y=-5, text='Cl\u207b', showarrow=False),\n        # Diamond Labels (simplified)\n        dict(x=75, y=43.3, text='Ca-HCO\u2083', showarrow=False),\n        dict(x=125, y=43.3, text='Na-Cl', showarrow=False),\n    ]\n)\n\nst.plotly_chart(fig, use_container_width=True)\n\n# Data Table\nst.header(\"Sample Data Table\")\nst.dataframe(df)",
    "title": "Interactive Piper Diagram for Water Chemistry Analysis",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "6988cad2-00bc-4cd5-beb1-7fea51bcb6e3": {
    "id": "6988cad2-00bc-4cd5-beb1-7fea51bcb6e3",
    "created_at": "2025-04-17T13:59:49.618492",
    "updated_at": "2025-04-17T14:07:37.697562",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Suppress warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# --- Introduction to Piper Diagrams ---\nst.title(\"Interactive Piper Diagram for Hydrogeochemical Analysis\")\n\nst.markdown(\"\"\"\n**What is a Piper Diagram?**\n\nA Piper diagram is a graphical representation used in hydrogeochemistry to visualize and classify water samples based on their major ion chemistry. It consists of three parts: two triangles representing the cation and anion compositions, and a central diamond field where the water types are classified.\n\n**How to Interpret a Piper Diagram:**\n\n1. **Triangles:** The cation triangle plots the relative percentages of major cations (Calcium, Magnesium, Sodium + Potassium), while the anion triangle plots the relative percentages of major anions (Bicarbonate + Carbonate, Sulfate, Chloride).\n2. **Diamond Field:** The data points from the triangles are projected onto the diamond field, which helps in classifying the water type based on the dominant ions. The diamond plot shows the combined cation and anion facies, allowing for a comprehensive understanding of the water's geochemical character.\n3. **Water Types:** Different regions of the diamond field represent different water types (e.g., Calcium-Bicarbonate, Sodium-Chloride). The position of a sample in the diamond indicates its dominant ion composition and potential origin.\n\n**Use:**\n\nPiper diagrams are useful for understanding groundwater evolution, water-rock interactions, and mixing processes. By visualizing the relative concentrations of major ions, we can infer the source of the water, the geological formations it has interacted with, and the processes that have altered its chemical composition.\n\"\"\")\n\n# --- Sample Data ---\n# Sample data for common water types (meq/L)\ndata = {\n    'Sample': ['Freshwater 1', 'Freshwater 2', 'Seawater', 'Brine', 'Acid Mine Drainage', 'Limestone Aquifer', 'Granite Aquifer'],\n    'Ca': [1.5, 2.0, 10.5, 50.0, 25.0, 4.0, 0.5],\n    'Mg': [0.5, 1.0, 52.0, 150.0, 10.0, 1.0, 0.2],\n    'Na': [1.0, 1.5, 450.0, 1000.0, 5.0, 0.5, 3.0],\n    'K': [0.2, 0.3, 10.0, 20.0, 1.0, 0.1, 0.1],\n    'HCO3': [2.5, 3.0, 20.0, 5.0, 0.1, 5.0, 1.0],\n    'SO4': [0.5, 1.0, 25.0, 500.0, 50.0, 0.2, 1.5],\n    'Cl': [0.2, 0.5, 500.0, 1500.0, 10.0, 0.1, 0.5],\n    'Water Type': ['Freshwater', 'Freshwater', 'Seawater', 'Brine', 'Acid Mine Drainage', 'Limestone', 'Granite']\n}\ndf = pd.DataFrame(data)\n\n# Create a color map for water types\nall_water_types = df['Water Type'].unique()\nwater_type_colors = {\n    water_type: f\"hsl({i * 360 // len(all_water_types)}, 70%, 50%)\" \n    for i, water_type in enumerate(all_water_types)\n}\n\n# --- Sidebar for User Input ---\nst.sidebar.header(\"Input New Water Sample Data\")\nsample_name = st.sidebar.text_input(\"Sample Name\", \"New Sample\")\nca_input = st.sidebar.number_input(\"Ca\u00b2\u207a (meq/L)\", value=2.0, min_value=0.0, format=\"%.2f\")\nmg_input = st.sidebar.number_input(\"Mg\u00b2\u207a (meq/L)\", value=1.0, min_value=0.0, format=\"%.2f\")\nna_input = st.sidebar.number_input(\"Na\u207a (meq/L)\", value=1.5, min_value=0.0, format=\"%.2f\")\nk_input = st.sidebar.number_input(\"K\u207a (meq/L)\", value=0.3, min_value=0.0, format=\"%.2f\")\nhco3_input = st.sidebar.number_input(\"HCO\u2083\u207b (meq/L)\", value=3.0, min_value=0.0, format=\"%.2f\")\nso4_input = st.sidebar.number_input(\"SO\u2084\u00b2\u207b (meq/L)\", value=1.0, min_value=0.0, format=\"%.2f\")\ncl_input = st.sidebar.number_input(\"Cl\u207b (meq/L)\", value=0.5, min_value=0.0, format=\"%.2f\")\nwater_type_input = st.sidebar.selectbox(\"Water Type\", [\"Unknown\"] + list(all_water_types))\n\n# Check if inputs are valid\ninput_valid = True\nerror_message = \"\"\n\nif (ca_input + mg_input + na_input + k_input) == 0:\n    input_valid = False\n    error_message += \"Total cations must be greater than 0. \"\n\nif (hco3_input + so4_input + cl_input) == 0:\n    input_valid = False\n    error_message += \"Total anions must be greater than 0.\"\n\nif not input_valid:\n    st.sidebar.error(error_message)\n\n# Add new sample data to dataframe\nif st.sidebar.button(\"Add Sample\") and input_valid:\n    new_sample = {\n        'Sample': sample_name,\n        'Ca': ca_input,\n        'Mg': mg_input,\n        'Na': na_input,\n        'K': k_input,\n        'HCO3': hco3_input,\n        'SO4': so4_input,\n        'Cl': cl_input,\n        'Water Type': water_type_input\n    }\n    df = pd.concat([df, pd.DataFrame([new_sample])], ignore_index=True)\n    \n    # Update color map if new water type\n    if water_type_input not in water_type_colors and water_type_input != \"Unknown\":\n        all_water_types = df['Water Type'].unique() # Update all_water_types\n        water_type_colors[water_type_input] = f\"hsl({len(water_type_colors) * 360 // (len(all_water_types))}, 70%, 50%)\"\n    \n    st.success(f\"Added sample: {sample_name}\")\n    st.rerun()\n\n# --- Normalize Ion Concentrations ---\ndef normalize_ions(df):\n    # Create a copy to avoid warning\n    result = df.copy()\n    \n    # Calculate sum of cations and anions for each row\n    result['cations_sum'] = result['Ca'] + result['Mg'] + result['Na'] + result['K']\n    result['anions_sum'] = result['HCO3'] + result['SO4'] + result['Cl']\n    \n    # Calculate percentages\n    result['Ca_percent'] = (result['Ca'] / result['cations_sum']) * 100\n    result['Mg_percent'] = (result['Mg'] / result['cations_sum']) * 100\n    result['NaK_percent'] = ((result['Na'] + result['K']) / result['cations_sum']) * 100\n    \n    result['HCO3_percent'] = (result['HCO3'] / result['anions_sum']) * 100\n    result['SO4_percent'] = (result['SO4'] / result['anions_sum']) * 100\n    result['Cl_percent'] = (result['Cl'] / result['anions_sum']) * 100\n    \n    return result\n\n# Apply normalization\nnormalized_df = normalize_ions(df)\n\n# --- Functions to convert percentages to plotting coordinates ---\ndef get_cation_coordinates(row):\n    # For cation triangle\n    x = 100 - row['NaK_percent']  # Ca side is at 100%, Na+K at 0%\n    y = row['Mg_percent'] * np.sqrt(3) / 2  # Height of equilateral triangle\n    return x, y\n\ndef get_anion_coordinates(row):\n    # For anion triangle (offset to the right)\n    x = 100 + row['Cl_percent']  # HCO3 side is at 100%, Cl at 200%\n    y = row['SO4_percent'] * np.sqrt(3) / 2\n    return x, y\n\ndef get_diamond_coordinates(row):\n    # Project points to the diamond\n    cation_x, cation_y = get_cation_coordinates(row)\n    anion_x, anion_y = get_anion_coordinates(row)\n    \n    # Diamond coordinates (simple average of the triangles)\n    x = (cation_x + anion_x) / 2\n    y = (cation_y + anion_y) / 2\n    return x, y\n\n# --- Piper Diagram Plotting ---\ndef create_piper_diagram(df, color_by='Water Type'):\n    fig = go.Figure()\n    \n    # Create coordinate lists\n    cation_x = []\n    cation_y = []\n    anion_x = []\n    anion_y = []\n    diamond_x = []\n    diamond_y = []\n    \n    for _, row in df.iterrows():\n        # Calculate coordinates for each sample\n        cx, cy = get_cation_coordinates(row)\n        ax, ay = get_anion_coordinates(row)\n        dx, dy = get_diamond_coordinates(row)\n        \n        cation_x.append(cx)\n        cation_y.append(cy)\n        anion_x.append(ax)\n        anion_y.append(ay)\n        diamond_x.append(dx)\n        diamond_y.append(dy)\n    \n    # Set colors based on selected option\n    if color_by == 'Water Type':\n        colors = [water_type_colors.get(wt, \"gray\") for wt in df['Water Type']]\n    else:  # Sample name\n        import plotly.express as px\n        colors = px.colors.qualitative.Plotly[:len(df)]\n    \n    # Add the three sets of points\n    for point_type, x, y in [\n        (\"Cations\", cation_x, cation_y),\n        (\"Anions\", anion_x, anion_y),\n        (\"Diamond\", diamond_x, diamond_y)\n    ]:\n        name = point_type\n        showlegend = (point_type == \"Diamond\")  # Only show legend for diamond points\n        \n        hover_text = []\n        for i, row in df.iterrows():\n            hover_text.append(\n                f\"Sample: {row['Sample']}<br>\"\n                f\"Water Type: {row['Water Type']}<br>\"\n                f\"Ca: {row['Ca_percent']:.1f}%<br>\"\n                f\"Mg: {row['Mg_percent']:.1f}%<br>\"\n                f\"Na+K: {row['NaK_percent']:.1f}%<br>\"\n                f\"HCO\u2083: {row['HCO3_percent']:.1f}%<br>\"\n                f\"SO\u2084: {row['SO4_percent']:.1f}%<br>\"\n                f\"Cl: {row['Cl_percent']:.1f}%\"\n            )\n            \n        fig.add_trace(go.Scatter(\n            x=x,\n            y=y,\n            mode='markers',\n            marker=dict(\n                color=colors,\n                size=10,\n                line=dict(width=1, color='Black')\n            ),\n            text=hover_text,\n            hovertemplate=\"%{text}<extra></extra>\",\n            name=name if showlegend else None,\n            showlegend=showlegend,\n            legendgroup=\"samples\"\n        ))\n    \n    # Add water type legend\n    if color_by == 'Water Type':\n        for water_type, color in water_type_colors.items():\n            fig.add_trace(go.Scatter(\n                x=[None], y=[None],  # No data points, just for legend\n                mode='markers',\n                marker=dict(color=color, size=10),\n                name=water_type\n            ))\n    \n    # Define triangle and diamond boundaries\n    # Cation triangle\n    fig.add_trace(go.Scatter(\n        x=[0, 100, 50, 0],\n        y=[0, 0, 86.6, 0],\n        mode='lines',\n        line=dict(color='black', width=2),\n        fill=None,\n        name='Cation Triangle',\n        showlegend=False\n    ))\n    \n    # Anion triangle\n    fig.add_trace(go.Scatter(\n        x=[100, 200, 150, 100],\n        y=[0, 0, 86.6, 0],\n        mode='lines',\n        line=dict(color='black', width=2),\n        fill=None,\n        name='Anion Triangle',\n        showlegend=False\n    ))\n    \n    # Diamond\n    fig.add_trace(go.Scatter(\n        x=[50, 100, 150, 100, 50],\n        y=[86.6, 173.2, 86.6, 0, 86.6],\n        mode='lines',\n        line=dict(color='black', width=2),\n        fill=None,\n        name='Diamond',\n        showlegend=False\n    ))\n    \n    # Add grid lines within triangles and labels\n    # Grid lines in cation triangle\n    for i in range(20, 100, 20):\n        # Lines parallel to base\n        fig.add_trace(go.Scatter(\n            x=[i/2, 100-i/2],\n            y=[i*np.sqrt(3)/2, i*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from left vertex\n        fig.add_trace(go.Scatter(\n            x=[i, 50+(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from right vertex\n        fig.add_trace(go.Scatter(\n            x=[100-i, 50-(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n    \n    # Identical grid lines for anion triangle (shifted)\n    for i in range(20, 100, 20):\n        # Lines parallel to base\n        fig.add_trace(go.Scatter(\n            x=[100+i/2, 200-i/2],\n            y=[i*np.sqrt(3)/2, i*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from left vertex\n        fig.add_trace(go.Scatter(\n            x=[100+i, 150+(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from right vertex\n        fig.add_trace(go.Scatter(\n            x=[200-i, 150-(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n    \n    # Add labels\n    annotations = [\n        # Cation Triangle\n        dict(x=0, y=-5, text=\"Ca\u00b2\u207a 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=100, y=-5, text=\"Na\u207a+K\u207a 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=50, y=90, text=\"Mg\u00b2\u207a 100%\", showarrow=False, font=dict(size=12)),\n        \n        # Anion Triangle\n        dict(x=100, y=-5, text=\"HCO\u2083\u207b+CO\u2083\u00b2\u207b 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=200, y=-5, text=\"Cl\u207b 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=150, y=90, text=\"SO\u2084\u00b2\u207b 100%\", showarrow=False, font=dict(size=12)),\n        \n        # Diamond Water Types\n        dict(x=50, y=40, text=\"Ca-HCO\u2083\", showarrow=False, font=dict(size=10)),\n        dict(x=150, y=40, text=\"Na-Cl\", showarrow=False, font=dict(size=10)),\n        dict(x=100, y=140, text=\"Ca/Mg-SO\u2084\", showarrow=False, font=dict(size=10)),\n        dict(x=100, y=20, text=\"Na-HCO\u2083\", showarrow=False, font=dict(size=10)),\n    ]\n    \n    # Layout configuration\n    fig.update_layout(\n        title=\"Piper Diagram\",\n        height=700,\n        width=1000,\n        xaxis=dict(\n            showgrid=False,\n            zeroline=False,\n            showticklabels=False,\n            range=[-10, 210]\n        ),\n        yaxis=dict(\n            showgrid=False,\n            zeroline=False,\n            showticklabels=False,\n            range=[-10, 190],\n            scaleanchor=\"x\",\n            scaleratio=1  # Keep aspect ratio 1:1\n        ),\n        annotations=annotations,\n        plot_bgcolor='rgba(240,240,240,0.8)'\n    )\n    \n    return fig\n\n# --- Toggle Sample Groups ---\nst.markdown(\"## Sample Visualization\")\ncol1, col2 = st.columns(2)\n\nwith col1:\n    unique_water_types = df['Water Type'].unique().tolist()\n    selected_water_types = st.multiselect(\n        \"Select Water Types to Display\", \n        unique_water_types, \n        default=unique_water_types\n    )\n\nwith col2:\n    color_option = st.radio(\"Color Points By\", ['Water Type', 'Sample'])\n\n# Filter data based on selection\nfiltered_df = normalized_df[normalized_df['Water Type'].isin(selected_water_types)]\n\n# Create and display the diagram\nif not filtered_df.empty:\n    fig = create_piper_diagram(filtered_df, color_by=color_option)\n    st.plotly_chart(fig, use_container_width=True)\nelse:\n    st.warning(\"No data to display. Please select at least one water type.\")\n\n# --- Data Tables ---\nst.markdown(\"## Data Tables\")\ntab1, tab2 = st.tabs([\"Original Data (meq/L)\", \"Normalized Data (%)\"])\n\nwith tab1:\n    st.dataframe(df.style.format({\n        'Ca': '{:.2f}',\n        'Mg': '{:.2f}',\n        'Na': '{:.2f}',\n        'K': '{:.2f}',\n        'HCO3': '{:.2f}',\n        'SO4': '{:.2f}',\n        'Cl': '{:.2f}'\n    }))\n\nwith tab2:\n    display_cols = ['Sample', 'Water Type', 'Ca_percent', 'Mg_percent', 'NaK_percent', \n                    'HCO3_percent', 'SO4_percent', 'Cl_percent']\n    st.dataframe(normalized_df[display_cols].style.format({\n        'Ca_percent': '{:.1f}%',\n        'Mg_percent': '{:.1f}%',\n        'NaK_percent': '{:.1f}%',\n        'HCO3_percent': '{:.1f}%',\n        'SO4_percent': '{:.1f}%',\n        'Cl_percent': '{:.1f}%'\n    }))\n\n# --- Download Options ---\nst.markdown(\"## Download Data\")\ncol1, col2 = st.columns(2)\n\nwith col1:\n    csv_original = df.to_csv(index=False)\n    st.download_button(\n        label=\"Download Original Data (CSV)\",\n        data=csv_original,\n        file_name=\"piper_diagram_data.csv\",\n        mime=\"text/csv\"\n    )\n\nwith col2:\n    csv_normalized = normalized_df.to_csv(index=False)\n    st.download_button(\n        label=\"Download Normalized Data (CSV)\",\n        data=csv_normalized,\n        file_name=\"piper_diagram_normalized_data.csv\",\n        mime=\"text/csv\"\n    )\n\n# --- Interpretation Guidance ---\nst.markdown(\"## Interpreting the Piper Diagram\")\nst.write(\"\"\"\nBy observing where the water samples plot on the Piper diagram, you can infer their dominant ion chemistry and potential origins.\n\n*   **Ca-HCO\u2083 type:** Typically found in shallow groundwater systems interacting with carbonate rocks like limestone. This water is usually fresh and reflects recently recharged groundwater.\n\n*   **Na-Cl type:** Often associated with seawater intrusion, saline aquifers, or dissolution of halite deposits. This water type is common in deep basins, connate water, and areas affected by evaporation.\n\n*   **Ca/Mg-SO\u2084 type:** May indicate interaction with dolomitic rocks or evaporite deposits containing gypsum or anhydrite. Also common in areas affected by acid mine drainage or pyrite oxidation.\n\n*   **Na-HCO\u2083 type:** Often results from ion exchange processes where calcium in groundwater is exchanged for sodium in clay minerals. This water type is common in deeper, more evolved groundwater systems.\n\n*   **Mixed type:** Represents waters with no clear dominance of specific ion combinations, indicating mixing of different water sources or complex geochemical processes.\n\nThe water samples' position on the diagram can also indicate:\n\n* **Evolutionary trends:** Samples often follow a path from Ca-HCO\u2083 \u2192 Na-HCO\u2083 \u2192 Na-Cl as they evolve along a flowpath\n* **Mixing lines:** Linear arrangements of points between two end-members may indicate mixing of different water sources\n* **Contamination:** Unusual positions or shifts can indicate anthropogenic impacts\n\"\"\")\n\n# Add references\nst.markdown(\"## References\")\nst.markdown(\"\"\"\n1. Piper, A.M., 1944. A graphic procedure in the geochemical interpretation of water-analyses. Transactions, American Geophysical Union, 25(6), pp.914-928.\n2. Freeze, R.A. and Cherry, J.A., 1979. Groundwater. Prentice-Hall, Inc., Englewood Cliffs, NJ.\n3. Hem, J.D., 1985. Study and interpretation of the chemical characteristics of natural water (Vol. 2254). Department of the Interior, US Geological Survey.\n\"\"\")",
    "title": "Interactive Piper Diagram for Water Geochemistry",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "003306f7-7d7c-45e8-8ff7-d9266b207997": {
    "id": "003306f7-7d7c-45e8-8ff7-d9266b207997",
    "created_at": "2025-04-17T14:08:01.448324",
    "updated_at": "2025-04-17T14:08:37.697603",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nst.title(\"Interactive Piper Diagram\")\n\nst.markdown(\"\"\"\nA Piper diagram is a graphical representation of the major ion chemistry of water samples. It is used to classify and compare water samples, understand their geochemical evolution, and infer water-rock interactions.\n\n**How to Interpret:**\n\n*   **Triangles:** Represent the percentage composition of major cations (Ca2+, Mg2+, Na+ + K+) and anions (HCO3- + CO32-, SO42-, Cl-).\n*   **Diamond:** Projects the data from the triangles to show overall water type classification (e.g., Ca-HCO3 type, Na-Cl type).  The central diamond is key for classifying water types.\n*   **Data Trends:**  The position of data points reveals trends in water chemistry, indicating mixing, weathering, or other geochemical processes. For example, waters evolving from fresh to saline conditions often migrate from the Ca-HCO3 region towards the Na-Cl region.\n\n\"\"\")\n\n# Sample Data\nsample_data = {\n    'Sample': ['Freshwater 1', 'Freshwater 2', 'Seawater', 'Brine 1', 'Brine 2', 'Acid Mine Drainage'],\n    'Ca': [60, 40, 15, 5, 2, 70],  # meq/L\n    'Mg': [20, 30, 5, 2, 1, 10],  # meq/L\n    'Na': [10, 20, 400, 1000, 2000, 5],  # meq/L\n    'K': [10, 10, 10, 5, 4, 15], # meq/L\n    'HCO3': [70, 60, 10, 2, 1, 5],  # meq/L\n    'SO4': [10, 20, 200, 500, 1000, 80],  # meq/L\n    'Cl': [5, 10, 400, 1000, 2000, 10],  # meq/L\n    'CO3': [15, 10, 0, 0, 0, 5], # meq/L\n    'Type': ['Freshwater', 'Freshwater', 'Seawater', 'Brine', 'Brine', 'Acid Mine Drainage']\n}\ndf = pd.DataFrame(sample_data)\n\n# Sidebar for User Input\nst.sidebar.header(\"Enter New Water Sample Data\")\nsample_name = st.sidebar.text_input(\"Sample Name\", \"New Sample\")\nca_input = st.sidebar.number_input(\"Ca\u00b2\u207a (meq/L)\", value=50.0)\nmg_input = st.sidebar.number_input(\"Mg\u00b2\u207a (meq/L)\", value=20.0)\nna_input = st.sidebar.number_input(\"Na\u207a (meq/L)\", value=10.0)\nk_input = st.sidebar.number_input(\"K\u207a (meq/L)\", value=10.0)\nhco3_input = st.sidebar.number_input(\"HCO\u2083\u207b (meq/L)\", value=60.0)\nso4_input = st.sidebar.number_input(\"SO\u2084\u00b2\u207b (meq/L)\", value=10.0)\ncl_input = st.sidebar.number_input(\"Cl\u207b (meq/L)\", value=5.0)\nco3_input = st.sidebar.number_input(\"CO\u2083\u00b2\u207b (meq/L)\", value=15.0)\nsample_type = st.sidebar.text_input(\"Sample Type\", \"User Defined\")\n\nadd_sample = st.sidebar.button(\"Add Sample\")\n\nif add_sample:\n    new_sample = {\n        'Sample': sample_name,\n        'Ca': ca_input,\n        'Mg': mg_input,\n        'Na': na_input,\n        'K': k_input,\n        'HCO3': hco3_input,\n        'SO4': so4_input,\n        'Cl': cl_input,\n        'CO3': co3_input,\n        'Type': sample_type\n    }\n    df = pd.concat([df, pd.DataFrame(new_sample, index=[0])], ignore_index=True)\n\n# Normalization Function\ndef normalize_ions(df):\n    df['Cations_Sum'] = df['Ca'] + df['Mg'] + df['Na'] + df['K']\n    df['Anions_Sum'] = df['HCO3'] + df['SO4'] + df['Cl'] + df['CO3']\n\n    df['Ca_percent'] = (df['Ca'] / df['Cations_Sum']) * 100\n    df['Mg_percent'] = (df['Mg'] / df['Cations_Sum']) * 100\n    df['NaK_percent'] = ((df['Na'] + df['K']) / df['Cations_Sum']) * 100\n\n    df['HCO3CO3_percent'] = ((df['HCO3'] + df['CO3']) / df['Anions_Sum']) * 100\n    df['SO4_percent'] = (df['SO4'] / df['Anions_Sum']) * 100\n    df['Cl_percent'] = (df['Cl'] / df['Anions_Sum']) * 100\n    return df\n\ndf = normalize_ions(df)\n\n# Sample Group Toggles\nst.sidebar.header(\"Toggle Sample Groups\")\nunique_types = df['Type'].unique()\nselected_types = {}\nfor water_type in unique_types:\n    selected_types[water_type] = st.sidebar.checkbox(water_type, value=True)\n\nfiltered_df = df[df['Type'].isin([k for k, v in selected_types.items() if v])]\n\n# Piper Diagram Plotting\nfig = go.Figure()\n\n# Get unique types *after* filtering\nunique_types_filtered = filtered_df['Type'].unique()\ncolor_map = {t: px.colors.qualitative.Dark24[i % len(px.colors.qualitative.Dark24)] for i, t in enumerate(unique_types_filtered)}\nfiltered_df['Color'] = filtered_df['Type'].map(color_map)\n\n\n# Cation Triangle\nfig.add_trace(go.Scatter(\n    x=filtered_df['Ca_percent'],\n    y=filtered_df['Mg_percent'],\n    mode='markers',\n    marker=dict(\n        size=10,\n        color=filtered_df['Color'],\n        line=dict(width=0.5, color='Black')\n    ),\n    text=[f\"Sample: {row['Sample']}<br>Ca: {row['Ca_percent']:.2f}%<br>Mg: {row['Mg_percent']:.2f}%<br>Na+K: {row['NaK_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\",\n    name=\"Cations\"\n))\n\n# Anion Triangle\nfig.add_trace(go.Scatter(\n    x=filtered_df['HCO3CO3_percent'] + 50,\n    y=filtered_df['SO4_percent'],\n    mode='markers',\n    marker=dict(\n        size=10,\n        color=filtered_df['Color'],\n        line=dict(width=0.5, color='Black')\n    ),\n    text=[f\"Sample: {row['Sample']}<br>HCO3+CO3: {row['HCO3CO3_percent']:.2f}%<br>SO4: {row['SO4_percent']:.2f}%<br>Cl: {row['Cl_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\",\n    name=\"Anions\"\n))\n\n# Diamond Plot (Approximate Calculation for Demonstration)\ndiamond_x = (filtered_df['Ca_percent'] + filtered_df['NaK_percent']*0 + (filtered_df['HCO3CO3_percent'] + 50) + (filtered_df['Cl_percent']*0 + 50) )/2\ndiamond_y = (filtered_df['Mg_percent']*0 + (100-filtered_df['NaK_percent']) + filtered_df['SO4_percent']*0 + (100 - filtered_df['Cl_percent']))/2\n\nfig.add_trace(go.Scatter(\n    x=diamond_x,\n    y=diamond_y,\n    mode='markers',\n    marker=dict(\n        size=10,\n        color=filtered_df['Color'],\n        line=dict(width=0.5, color='Black')\n    ),\n    text=[f\"Sample: {row['Sample']}<br>Ca: {row['Ca_percent']:.2f}%<br>Mg: {row['Mg_percent']:.2f}%<br>Na+K: {row['NaK_percent']:.2f}%<br>HCO3+CO3: {row['HCO3CO3_percent']:.2f}%<br>SO4: {row['SO4_percent']:.2f}%<br>Cl: {row['Cl_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\",\n    name=\"Diamond\"\n))\n\nfig.update_layout(\n    title=\"Piper Diagram\",\n    xaxis=dict(title=\"Cations (Ca, Mg, Na+K)\", range=[0, 100], showgrid=False),\n    yaxis=dict(title=\"Anions (HCO3+CO3, SO4, Cl)\", range=[0, 100], showgrid=False),\n    xaxis2=dict(title=\"HCO3+CO3\", overlaying='x', side='top', range=[50,150], showgrid=False),\n    yaxis2=dict(title=\"SO4\", overlaying='y', side='right', range=[0, 100], showgrid=False),\n    showlegend=True\n)\nfig.update_layout(xaxis2=dict(visible=False),\n                  yaxis2=dict(visible=False))\n\n#Add annotations for Piper Diagram regions\nfig.add_annotation(\n    text=\"Ca\",\n    x=0,\n    y=-0.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"Mg\",\n    x=0,\n    y=1.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"Na+K\",\n    x=1,\n    y=-0.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"HCO3+CO3\",\n    x=0.5,\n    y=1.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"SO4\",\n    x=1,\n    y=-0.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"Cl\",\n    x=0,\n    y=-0.1,\n    xref=\"x2\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nst.plotly_chart(fig, use_container_width=True)\n\n# Display Data Table\nst.header(\"Sample Data Table\")\nst.dataframe(filtered_df)",
    "title": "Interactive Piper Diagram for Water Chemistry Analysis",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "57cece56-75a9-4052-8283-e2eb812251fa": {
    "id": "57cece56-75a9-4052-8283-e2eb812251fa",
    "created_at": "2025-07-24T10:12:05.512258",
    "updated_at": "2025-07-24T10:13:25.432947",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Iris Dataset Visualization\")\nst.markdown(\"A simple scatter plot showing sepal length vs. sepal width, colored by species.\")\n\ntry:\n    iris_data = pd.read_csv('./upload/iris.csv')\nexcept FileNotFoundError:\n    st.error(\"Error: The file 'iris.csv' was not found in the './upload/' directory. Please upload the file.\")\n    st.stop()\n\n# Data Preview\nif st.checkbox(\"Show Raw Data\"):\n    st.subheader(\"Raw Data\")\n    st.dataframe(iris_data)\n\n\n# Scatter Plot\nst.subheader(\"Sepal Length vs. Sepal Width\")\n\n# Define a color palette (using Plotly's built-in palettes)\ncolor_palette = px.colors.qualitative.Dark24\n\n# Scatter Plot using Plotly Express (forced selection, Matplotlib option removed)\nfig = px.scatter(iris_data, x=\"sepal.length\", y=\"sepal.width\", color=\"variety\",\n                    labels={\"sepal.length\": \"Sepal Length (cm)\", \"sepal.width\": \"Sepal Width (cm)\", \"variety\": \"Species\"},\n                    title=\"Sepal Length vs. Sepal Width by Species (Plotly Express)\",\n                    color_discrete_sequence=color_palette)\nst.plotly_chart(fig, use_container_width=True)\n\n\n# Add some educational text\nst.markdown(\"---\")\nst.markdown(\"This plot visualizes the relationship between sepal length and sepal width for different species of Iris flowers. You can observe how the species tend to cluster based on these two features.\")",
    "title": "Iris Sepal Dimensions: Length vs. Width by Species",
    "description": "",
    "tags": [],
    "used_csv": "iris.csv"
  }
}