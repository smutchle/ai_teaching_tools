{
  "daa78010-c289-40ea-80cb-dc4f0d05b376": {
    "id": "daa78010-c289-40ea-80cb-dc4f0d05b376",
    "created_at": "2025-04-07T15:37:17.833679",
    "updated_at": "2025-04-07T15:37:17.833679",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\n\nst.title(\"Black-Scholes Option Pricing Simulation\")\n\n# Input parameters\nstock_price = st.number_input(\"Current Stock Price (S)\", value=100.0, min_value=0.0)\nstrike_price = st.number_input(\"Strike Price (K)\", value=100.0, min_value=0.0)\ntime_to_expiration = st.number_input(\"Time to Expiration (T in years)\", value=1.0, min_value=0.0)\nrisk_free_rate = st.number_input(\"Risk-Free Interest Rate (r)\", value=0.05, min_value=0.0)\nvolatility = st.number_input(\"Volatility (\u03c3)\", value=0.20, min_value=0.0)\nnumber_of_simulations = st.number_input(\"Number of Simulations\", value=1000, min_value=1)\n\n# Black-Scholes Formula (Call Option)\ndef black_scholes_call(S, K, T, r, sigma):\n    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    call_price = S * scipy.stats.norm.cdf(d1) - K * np.exp(-r * T) * scipy.stats.norm.cdf(d2)\n    return call_price\n\n# Calculate Black-Scholes price\ncall_price = black_scholes_call(stock_price, strike_price, time_to_expiration, risk_free_rate, volatility)\nst.write(f\"Black-Scholes Call Option Price: {call_price:.2f}\")\n\n# Simulate stock prices\nnp.random.seed(42) # for reproducibility\nz = np.random.standard_normal(number_of_simulations)\nST = stock_price * np.exp((risk_free_rate - 0.5 * volatility ** 2) * time_to_expiration + volatility * np.sqrt(time_to_expiration) * z)\n\n# Calculate option payoffs\npayoffs = np.maximum(ST - strike_price, 0)\n\n# Discount payoffs to present value\ndiscount_factor = np.exp(-risk_free_rate * time_to_expiration)\noption_prices = discount_factor * payoffs\n\n# Monte Carlo estimate of option price\nmonte_carlo_price = np.mean(option_prices)\nst.write(f\"Monte Carlo Estimated Call Option Price: {monte_carlo_price:.2f}\")\n\n# Histogram of simulated option prices\nfig, ax = plt.subplots()\nax.hist(option_prices, bins=50, alpha=0.7, label='Simulated Option Prices')\nax.axvline(monte_carlo_price, color='red', linestyle='dashed', linewidth=1, label=f'Monte Carlo Price: {monte_carlo_price:.2f}')\nax.axvline(call_price, color='green', linestyle='dashed', linewidth=1, label=f'Black-Scholes Price: {call_price:.2f}')\nax.set_xlabel('Option Price')\nax.set_ylabel('Frequency')\nax.set_title('Monte Carlo Simulation of Call Option Prices')\nax.legend()\nst.pyplot(fig)\n\n# Distribution of simulated stock prices at expiration\nfig2, ax2 = plt.subplots()\nax2.hist(ST, bins=50, alpha=0.7, label='Simulated Stock Prices at Expiration')\nax2.axvline(strike_price, color='red', linestyle='dashed', linewidth=1, label=f'Strike Price: {strike_price:.2f}')\nax2.set_xlabel('Stock Price at Expiration')\nax2.set_ylabel('Frequency')\nax2.set_title('Monte Carlo Simulation of Stock Prices at Expiration')\nax2.legend()\nst.pyplot(fig2)\n\n# Sensitivity analysis (Greeks - approximate using small changes)\n\ndelta_h = 0.01 * stock_price\nstock_price_up = stock_price + delta_h\ncall_price_up = black_scholes_call(stock_price_up, strike_price, time_to_expiration, risk_free_rate, volatility)\ndelta = (call_price_up - call_price) / delta_h\n\nvega_h = 0.01\nvolatility_up = volatility + vega_h\ncall_price_vega_up = black_scholes_call(stock_price, strike_price, time_to_expiration, risk_free_rate, volatility_up)\nvega = (call_price_vega_up - call_price) / vega_h\n\nst.subheader(\"Option Greeks (Approximation)\")\nst.write(f\"Delta: {delta:.4f}\")\nst.write(f\"Vega: {vega:.4f}\")",
    "title": "Black-Scholes & Monte Carlo Option Pricing Simulator",
    "description": "",
    "tags": []
  },
  "fab0913a-4a36-4982-ad2b-050db990cc73": {
    "id": "fab0913a-4a36-4982-ad2b-050db990cc73",
    "created_at": "2025-04-07T15:38:02.114691",
    "updated_at": "2025-04-07T15:38:02.114691",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\n\nst.title(\"SVM with Non-Linear Data and Kernels\")\n\n# Generate sample non-linear data\nn_samples = st.slider(\"Number of samples:\", min_value=50, max_value=500, value=200, step=10)\nrandom_state = 42\nrng = np.random.RandomState(random_state)\nX = rng.randn(n_samples, 2)\ny = np.logical_xor(X[:, 0] > 0, X[:, 1] > 0)\ny = np.where(y, 1, 0)\n\ndf = pd.DataFrame(X, columns=['Feature 1', 'Feature 2'])\ndf['Target'] = y\n\n# Kernel selection\nkernel_options = ['linear', 'poly', 'rbf', 'sigmoid']\nselected_kernel = st.selectbox(\"Select Kernel:\", kernel_options)\n\n# SVM parameters (common to all kernels, with defaults)\nC = st.slider(\"Regularization (C):\", min_value=0.1, max_value=10.0, value=1.0, step=0.1)\n\n# Parameter specific to polynomial kernel\nif selected_kernel == 'poly':\n    degree = st.slider(\"Degree (for Poly Kernel):\", min_value=2, max_value=10, value=3, step=1)\n    clf = sklearn.svm.SVC(kernel=selected_kernel, C=C, degree=degree, random_state=random_state)\n# Parameter specific to rbf kernel\nelif selected_kernel == 'rbf':\n    gamma = st.slider(\"Gamma (for RBF Kernel):\", min_value=0.01, max_value=5.0, value=0.5, step=0.01)\n    clf = sklearn.svm.SVC(kernel=selected_kernel, C=C, gamma=gamma, random_state=random_state)\n# Parameter specific to sigmoid kernel\nelif selected_kernel == 'sigmoid':\n    gamma = st.slider(\"Gamma (for Sigmoid Kernel):\", min_value=0.01, max_value=5.0, value=0.5, step=0.01)\n    coef0 = st.slider(\"Coef0 (for Sigmoid Kernel):\", min_value=-5.0, max_value=5.0, value=0.0, step=0.1)\n    clf = sklearn.svm.SVC(kernel=selected_kernel, C=C, gamma=gamma, coef0=coef0, random_state=random_state)\nelse:\n    clf = sklearn.svm.SVC(kernel=selected_kernel, C=C, random_state=random_state)\n\n# Train the SVM model\nclf.fit(X, y)\n\n# Create a meshgrid for plotting the decision boundary\nx_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\ny_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\nxx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02),\n                     np.arange(y_min, y_max, 0.02))\n\n# Predict the class for each point in the meshgrid\nZ = clf.predict(np.c_[xx.ravel(), yy.ravel()])\nZ = Z.reshape(xx.shape)\n\n# Plotting using matplotlib\nfig, ax = plt.subplots(figsize=(8, 6))\nax.contourf(xx, yy, Z, cmap=plt.cm.RdBu, alpha=0.5)\nax.scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.RdBu, edgecolors='k')\nax.set_title(f\"SVM with {selected_kernel} kernel\")\nax.set_xlabel(\"Feature 1\")\nax.set_ylabel(\"Feature 2\")\n\n# Display the plot in Streamlit\nst.pyplot(fig)\n\n# Display model performance\ny_pred = clf.predict(X)\naccuracy = sklearn.metrics.accuracy_score(y, y_pred)\nst.write(f\"Accuracy: {accuracy:.2f}\")",
    "title": "SVM Kernel Explorer: Non-Linear Data Classification",
    "description": "",
    "tags": []
  }
}