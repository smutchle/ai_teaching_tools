{
  "b0739a1a-ca0a-41fa-9adb-dc05f84d6b85": {
    "id": "b0739a1a-ca0a-41fa-9adb-dc05f84d6b85",
    "created_at": "2025-04-07T19:05:22.433085",
    "updated_at": "2025-04-09T16:12:54.572040",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom PIL import Image\nimport warnings\nwarnings.filterwarnings('ignore')\n\nst.title(\"Image Compression with PCA\")\n\nst.write(\"This app demonstrates image compression using Principal Component Analysis (PCA). PCA reduces the dimensionality of the image data, allowing for smaller file sizes with some loss of detail.\")\n\n# Image Upload\nuploaded_file = st.file_uploader(\"Choose an image...\", type=[\"jpg\", \"jpeg\", \"png\"])\n\nif uploaded_file is not None:\n    image = Image.open(uploaded_file)\n    st.image(image, caption=\"Original Image\", use_container_width=True)\n\n    # Convert image to numpy array\n    img_array = np.array(image)\n\n    # Convert to Grayscale\n    if len(img_array.shape) == 3:\n        img_gray = np.dot(img_array[...,:3], [0.2989, 0.5870, 0.1140])\n    else:\n        img_gray = img_array\n\n    img_gray = img_gray.astype(np.uint8)\n\n    st.image(img_gray, caption=\"Grayscale Image\", use_container_width=True)\n    st.write(f\"Grayscale Image Shape: {img_gray.shape}\")\n\n    # Display the matrix of grayscale values\n    st.write(\"Grayscale Value Matrix:\")\n    st.dataframe(pd.DataFrame(img_gray))\n\n    # Number of components\n    n_components = st.slider(\"Number of Principal Components\", 1, img_gray.shape[1], img_gray.shape[1]//10)\n\n    # Reshape image into a matrix where each row is a pixel\n    img_matrix = img_gray\n\n    # Standardize the data\n    scaler = StandardScaler()\n    scaled_data = scaler.fit_transform(img_matrix)\n\n    # Apply PCA\n    pca = PCA(n_components=n_components)\n    pca.fit(scaled_data)\n    transformed_data = pca.transform(scaled_data)\n\n    # Inverse transform\n    inverse_data = pca.inverse_transform(transformed_data)\n\n    # Scale back to original range\n    inverse_data = scaler.inverse_transform(inverse_data)\n\n    # Clip values to be within the valid range\n    compressed_img = np.clip(inverse_data, 0, 255).astype(np.uint8)\n\n    # Display compressed image\n    st.image(compressed_img, caption=f\"Compressed Image with {n_components} Components\", use_container_width=True)\n\n    # Explained variance ratio\n    explained_variance = pca.explained_variance_ratio_\n    explained_variance_cumulative = np.cumsum(explained_variance)\n\n    # Plot explained variance\n    fig, ax = plt.subplots()\n    ax.plot(explained_variance_cumulative)\n    ax.set_xlabel(\"Number of Components\")\n    ax.set_ylabel(\"Cumulative Explained Variance\")\n    ax.set_title(\"Explained Variance vs. Number of Components\")\n    st.pyplot(fig)\n\n    # Display explained variance ratio data\n    variance_df = pd.DataFrame({'Component': range(1, len(explained_variance) + 1),\n                                  'Explained Variance': explained_variance,\n                                  'Cumulative Explained Variance': explained_variance_cumulative})\n    st.dataframe(variance_df)\n\n    # Compression Ratio\n    # The error was caused by trying to get the size of the uploaded file object directly.\n    # We need to save the file to a temporary location and then get the size.\n    temp_file = \"temp_image.jpg\"  # Or .png, depending on original\n    image.save(temp_file)\n    original_size = os.path.getsize(temp_file)\n    compressed_size = compressed_img.nbytes\n    compression_ratio = original_size / compressed_size\n    os.remove(temp_file)\n\n\n    st.write(f\"Original File Size: {original_size} bytes\")\n    st.write(f\"Compressed Image Size: {compressed_size} bytes\")\n    st.write(f\"Compression Ratio: {compression_ratio:.2f}\")\n\n    if st.button(\"Rerun\"):\n        st.rerun()\nelse:\n    st.write(\"Please upload an image to begin.\")",
    "title": "Image Compression with PCA using Streamlit",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "232d5513-d92f-42f1-a828-0a5f72a245b4": {
    "id": "232d5513-d92f-42f1-a828-0a5f72a245b4",
    "created_at": "2025-04-09T16:06:48.178903",
    "updated_at": "2025-07-24T09:57:41.127127",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Iris Dataset PCA Visualization\")\n\n# Load the Iris dataset\ntry:\n    iris_data = pd.read_csv('./upload/iris.csv')\nexcept FileNotFoundError:\n    st.error(\"The file 'iris.csv' was not found in the './upload/' directory.  Please upload the file or check the path.\")\n    st.stop()  # Stop execution if file is not found\n\nst.write(\"First 5 rows of the dataset:\")\nst.dataframe(iris_data.head())\n\n# Data Preprocessing\nfeatures = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width']\nX = iris_data[features]\ny = iris_data['Species']\n\n# Standardize the features\nfrom sklearn.preprocessing import StandardScaler\nX = StandardScaler().fit_transform(X)\n\n# PCA implementation\nfrom sklearn.decomposition import PCA\npca = PCA(n_components=2)\nprincipalComponents = pca.fit_transform(X)\nprincipalDf = pd.DataFrame(data = principalComponents, columns = ['PCA1', 'PCA2'])\n\n# Concatenate with species information\nfinalDf = pd.concat([principalDf, iris_data[['Species']]], axis = 1)\n\nst.subheader(\"Explained Variance Ratio\")\nst.write(pca.explained_variance_ratio_)\n\n# Scatter Plot using Plotly Express\nfig = px.scatter(finalDf, x='PCA1', y='PCA2', color='Species',\n                 title='PCA of Iris Dataset',\n                 labels={'PCA1': 'Principal Component 1', 'PCA2': 'Principal Component 2'},\n                 color_discrete_sequence=px.colors.qualitative.Dark24)\n\nst.plotly_chart(fig, use_container_width=True)",
    "title": "Iris Dataset: PCA Visualization",
    "description": "",
    "tags": [],
    "used_csv": "iris.csv"
  },
  "cd92d301-0c25-4c26-b2f5-3f3a255d1919": {
    "id": "cd92d301-0c25-4c26-b2f5-3f3a255d1919",
    "created_at": "2025-04-09T19:47:41.655440",
    "updated_at": "2025-04-09T19:50:07.148126",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n#st.set_option('deprecation.showPyplotGlobalUse', False)\n\nst.title(\"Image Convolution App\")\n\nuploaded_file = st.file_uploader(\"Choose an image...\", type=[\"jpg\", \"jpeg\", \"png\"])\n\nif uploaded_file is not None:\n    # Load the image\n    try:\n        image = plt.imread(uploaded_file)\n    except Exception as e:\n        st.error(f\"Error loading image: {e}\")\n        st.stop()\n\n    st.subheader(\"Original Image\")\n    st.image(image, caption=\"Uploaded Image\", use_container_width=True)\n\n    # Convert to grayscale\n    gray_image = np.dot(image[...,:3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)\n    st.subheader(\"Grayscale Image\")\n    st.image(gray_image, caption=\"Grayscale Image\", use_container_width=True)\n\n    # Define common kernels\n    kernels = {\n        \"Identity\": np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]]),\n        \"Sharpen\": np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]]),\n        \"Edge Detection\": np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]),\n        \"Box Blur\": (1/9) * np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]]),\n        \"Gaussian Blur\": (1/16) * np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]])\n    }\n\n    kernel_names = list(kernels.keys())\n\n    # Kernel selection\n    selected_kernel_name = st.selectbox(\"Select a Predefined Kernel\", kernel_names)\n\n    # Manual kernel input\n    st.subheader(\"Or Input Custom Kernel (3x3)\")\n    col1, col2, col3 = st.columns(3)\n    k11 = col1.number_input(\"k11\", value=0.0, format=\"%.2f\")\n    k12 = col2.number_input(\"k12\", value=0.0, format=\"%.2f\")\n    k13 = col3.number_input(\"k13\", value=0.0, format=\"%.2f\")\n    \n    col4, col5, col6 = st.columns(3)\n    k21 = col4.number_input(\"k21\", value=0.0, format=\"%.2f\")\n    k22 = col5.number_input(\"k22\", value=0.0, format=\"%.2f\")\n    k23 = col6.number_input(\"k23\", value=0.0, format=\"%.2f\")\n\n    col7, col8, col9 = st.columns(3)\n    k31 = col7.number_input(\"k31\", value=0.0, format=\"%.2f\")\n    k32 = col8.number_input(\"k32\", value=0.0, format=\"%.2f\")\n    k33 = col9.number_input(\"k33\", value=0.0, format=\"%.2f\")\n\n    custom_kernel = np.array([[k11, k12, k13], [k21, k22, k23], [k31, k32, k33]])\n\n    use_custom_kernel = st.checkbox(\"Use custom kernel?\")\n\n    if use_custom_kernel:\n        selected_kernel = custom_kernel\n        selected_kernel_name = \"Custom Kernel\"\n    else:\n        selected_kernel = kernels[selected_kernel_name]\n    \n    st.write(f\"Selected Kernel: {selected_kernel_name}\")\n    st.write(selected_kernel)\n\n\n    # Convolution operation (simplified for demonstration)\n    def convolve(image, kernel):\n        kernel_size = kernel.shape[0]\n        padding = kernel_size // 2\n        padded_image = np.pad(image, padding, mode='constant')\n        output_image = np.zeros_like(image, dtype=np.float64)\n\n        for x in range(image.shape[0]):\n            for y in range(image.shape[1]):\n                output_image[x, y] = np.sum(padded_image[x:x+kernel_size, y:y+kernel_size] * kernel)\n        \n        output_image = np.clip(output_image, 0, 255).astype(np.uint8)\n\n        return output_image\n\n    # Apply convolution\n    convolved_image = convolve(gray_image, selected_kernel)\n\n    # Display convolved image\n    st.subheader(\"Convolved Image\")\n    st.image(convolved_image, caption=f\"Convolved Image with {selected_kernel_name}\", use_container_width=True)",
    "title": "Image Convolution Explorer",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "fe686074-aed2-4c62-bb64-d692e234861b": {
    "id": "fe686074-aed2-4c62-bb64-d692e234861b",
    "created_at": "2025-04-17T13:45:54.995326",
    "updated_at": "2025-04-17T13:46:22.984606",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Aluminosilicate Phase Diagram\")\n\nst.markdown(\"\"\"\n    This interactive visualization explores the stability fields of andalusite, kyanite, and sillimanite \n    (Al<sub>2</sub>SiO<sub>5</sub> polymorphs) as a function of pressure and temperature. \n    These minerals are important indicators of metamorphic conditions in rocks.  \n    By understanding which mineral is stable at a given pressure and temperature, \n    geologists can infer the conditions under which a rock formed.\n    \"\"\")\n\n# Thermodynamic data (example - needs real data for accuracy!)\n# These values are placeholders.  Real thermodynamic data would be required for accurate representation.\nandalusite_G = lambda T, P, a_Al2O3, a_SiO2: 100000 + 0.08 * (T - 273.15) - 0.001 * P - np.log(a_Al2O3) - np.log(a_SiO2) # Gibbs Free Energy (arbitrary units)\nkyanite_G = lambda T, P, a_Al2O3, a_SiO2: 100050 + 0.07 * (T - 273.15) - 0.0012 * P - np.log(a_Al2O3) - np.log(a_SiO2)\nsillimanite_G = lambda T, P, a_Al2O3, a_SiO2: 100020 + 0.075 * (T - 273.15) - 0.0011 * P - np.log(a_Al2O3) - np.log(a_SiO2)\n\n# Define the grid of P-T conditions\nT = np.linspace(200, 800, 50) + 273.15 # Temperature in Celsius, converted to Kelvin\nP = np.linspace(0, 10, 50) * 1000  # Pressure in kbar, converted to bar (approximated)\n\n# Create a meshgrid\nT_grid, P_grid = np.meshgrid(T, P)\n\n# Interactive sliders for activities\na_Al2O3 = st.slider(\"Activity of Al2O3\", min_value=0.5, max_value=1.0, value=1.0, step=0.01)\na_SiO2 = st.slider(\"Activity of SiO2\", min_value=0.5, max_value=1.0, value=1.0, step=0.01)\n\n# Calculate Gibbs Free Energies for each mineral at each P-T point\nandalusite_G_values = andalusite_G(T_grid, P_grid, a_Al2O3, a_SiO2)\nkyanite_G_values = kyanite_G(T_grid, P_grid, a_Al2O3, a_SiO2)\nsillimanite_G_values = sillimanite_G(T_grid, P_grid, a_Al2O3, a_SiO2)\n\n# Determine the stable mineral at each P-T point\nstable_mineral = np.argmin([andalusite_G_values, kyanite_G_values, sillimanite_G_values], axis=0)\n\n# Create a DataFrame for easier plotting\ndf = pd.DataFrame({\n    'Temperature': T_grid.flatten() - 273.15,  # Convert back to Celsius\n    'Pressure': P_grid.flatten() / 1000,    # Convert back to kbar\n    'Stable Mineral': stable_mineral.flatten()\n})\n\n# Assign mineral names based on the index\nmineral_names = {0: 'Andalusite', 1: 'Kyanite', 2: 'Sillimanite'}\ndf['Mineral Name'] = df['Stable Mineral'].map(mineral_names)\n\n# 3D Scatter Plot\nfig = px.scatter_3d(df, x='Temperature', y='Pressure', z='Stable Mineral',\n                    color='Mineral Name',\n                    color_discrete_map={'Andalusite': 'red', 'Kyanite': 'blue', 'Sillimanite': 'green'},\n                    labels={'Temperature': 'Temperature (\u00b0C)', 'Pressure': 'Pressure (kbar)', 'Stable Mineral': 'Mineral'},\n                    title='Aluminosilicate Phase Diagram',\n                    hover_data=['Mineral Name'],\n                    )\n\nfig.update_layout(\n    scene=dict(\n        zaxis=dict(\n            tickvals=[0, 1, 2],\n            ticktext=['Andalusite', 'Kyanite', 'Sillimanite'],\n            title = \"Mineral\"\n        ),\n        xaxis_title='Temperature (\u00b0C)',\n        yaxis_title='Pressure (kbar)'\n    )\n)\nst.plotly_chart(fig, use_container_width=True)\n\n# 2D Slice at Selected Pressure/Temperature\nslice_type = st.radio(\"Select Slice Type:\", (\"Pressure\", \"Temperature\"))\n\nif slice_type == \"Pressure\":\n    pressure_slice = st.slider(\"Pressure for 2D Slice (kbar)\", min_value=0.0, max_value=10.0, value=5.0, step=0.1)\n    # Find the nearest pressure value in the grid\n    nearest_pressure_index = np.argmin(np.abs(P / 1000 - pressure_slice)) # P is in bar, convert to kbar\n    \n    # Extract the stable minerals and temperature for the slice\n    slice_data = df[df['Pressure'] == P[nearest_pressure_index]/1000]\n    \n    # Create a 2D plot\n    fig_2d = px.scatter(slice_data, x='Temperature', y='Mineral Name', color='Mineral Name',\n                        color_discrete_map={'Andalusite': 'red', 'Kyanite': 'blue', 'Sillimanite': 'green'},\n                        title=f'Aluminosilicate Phase Diagram at {pressure_slice:.1f} kbar')\n    fig_2d.update_layout(yaxis={'categoryorder':'array', 'categoryarray':['Andalusite', 'Kyanite', 'Sillimanite']})\n    st.plotly_chart(fig_2d, use_container_width=True)\n\nelif slice_type == \"Temperature\":\n    temperature_slice = st.slider(\"Temperature for 2D Slice (\u00b0C)\", min_value=200.0, max_value=800.0, value=500.0, step=10.0)\n    # Find the nearest temperature value in the grid\n    nearest_temperature_index = np.argmin(np.abs(T - 273.15 - temperature_slice)) # T is in Kelvin, convert to C\n    \n    # Extract the stable minerals and pressure for the slice\n    slice_data = df[df['Temperature'] == T[nearest_temperature_index] - 273.15]\n    \n    # Create a 2D plot\n    fig_2d = px.scatter(slice_data, x='Pressure', y='Mineral Name', color='Mineral Name',\n                        color_discrete_map={'Andalusite': 'red', 'Kyanite': 'blue', 'Sillimanite': 'green'},\n                        title=f'Aluminosilicate Phase Diagram at {temperature_slice:.1f} \u00b0C')\n    fig_2d.update_layout(yaxis={'categoryorder':'array', 'categoryarray':['Andalusite', 'Kyanite', 'Sillimanite']})\n    st.plotly_chart(fig_2d, use_container_width=True)",
    "title": "Interactive Aluminosilicate Phase Diagram Visualization",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "f8093968-16c0-4e44-b3c6-68f1ecf39922": {
    "id": "f8093968-16c0-4e44-b3c6-68f1ecf39922",
    "created_at": "2025-04-17T13:47:54.562850",
    "updated_at": "2025-04-17T13:48:05.271171",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n# --- Title and Introduction ---\nst.title(\"Aluminosilicate Phase Diagram\")\nst.write(\"This interactive diagram shows the stability fields of andalusite, kyanite, and sillimanite under different temperature and pressure conditions. These minerals are polymorphs of Al2SiO5 and are important indicators of metamorphic conditions.\")\n\n# --- Define Data for Stability Fields ---\n# Approximate coordinates for the stability fields (simplified for demonstration)\n# These are not precise thermodynamic calculations, but illustrative.\n\ntemp = np.linspace(200, 800, 100)  # Temperature in Celsius\npressure = np.linspace(0, 8, 100)  # Pressure in kbar\nT, P = np.meshgrid(temp, pressure)\n\n# Define fields based on simplified linear relationships\n# NOTE: These are NOT accurate thermodynamic calculations, but estimations to demonstrate plotting.\nandalusite = (P < 0.007 * T - 1.4) & (P > 0)\nkyanite = (P > 0.007 * T - 1.4) & (P > 0.012 * T - 1.6)\nsillimanite = (P > 0) & (P < 8) & (P > 0.012 * T - 1.6)\nno_mineral = ~(andalusite | kyanite | sillimanite) # Added a \"no mineral\" area to prevent plotting issues\n\n# --- Create the Plot ---\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the stability fields with different colors\ncontour_andalusite = ax.contourf(T, P, andalusite, levels=[0, 0.5, 1], colors=['coral'], alpha=0.5)\ncontour_kyanite = ax.contourf(T, P, kyanite, levels=[0, 0.5, 1], colors=['skyblue'], alpha=0.5)\ncontour_sillimanite = ax.contourf(T, P, sillimanite, levels=[0, 0.5, 1], colors=['lightgreen'], alpha=0.5)\nax.contourf(T, P, no_mineral, levels=[0, 0.5, 1], colors=['lightgrey'], alpha=0.5) # Plot the no mineral area\n\n\n# Plot the reaction boundaries as lines (simplified)\nax.plot(temp, 0.007 * temp - 1.4, 'k--', label='Andalusite/Kyanite')\nax.plot(temp, 0.012 * temp - 1.6, 'k:', label='Kyanite/Sillimanite')\n\n\n# Mark the triple point (approximate)\nax.plot(500, 4.5, 'ro', markersize=8, label='Triple Point')\nax.text(510, 4.5, 'Triple Point', color='red')\n\n# Add labels and title\nax.set_xlabel('Temperature (\u00b0C)')\nax.set_ylabel('Pressure (kbar)')\nax.set_title('Al2SiO5 Phase Diagram')\n\n# Set axis limits\nax.set_xlim(200, 800)\nax.set_ylim(0, 8)\n\n# Add legend\nhandles, labels = ax.get_legend_handles_labels()\nax.legend(handles, labels, loc='upper right')\n\n# Add grid\nax.grid(True)\n\n# --- Display Plot in Streamlit ---\nst.pyplot(fig, use_container_width=True)\n\n# --- Add Geological Significance Explanation ---\nst.subheader(\"Geological Significance\")\nst.write(\"This diagram is a powerful tool in metamorphic petrology. By analyzing the presence of andalusite, kyanite, or sillimanite in a metamorphic rock, geologists can estimate the temperature and pressure conditions under which the rock formed. The triple point represents the specific conditions where all three minerals can coexist in equilibrium, providing a precise constraint on the metamorphic environment.\")\n\nst.write(\"The placement of the reaction boundaries are estimates and can vary based on the specific composition of the rocks and the presence of other fluids.\")",
    "title": "Al2SiO5 Phase Diagram: Stability of Polymorphs",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "c7edb89e-21bb-4867-9d32-29d0697305b4": {
    "id": "c7edb89e-21bb-4867-9d32-29d0697305b4",
    "created_at": "2025-04-17T13:50:07.200119",
    "updated_at": "2025-04-17T13:50:24.755470",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.set_page_config(layout=\"wide\")\n\n# Define the vertices of the ternary diagram\nQ = (0, 0)  # Quartz\nA = (1, 0)  # Alkali Feldspar\nP = (0.5, np.sqrt(3)/2)  # Plagioclase\n\n# Define the classification boundaries (approximate)\n# These are simplified for demonstration and may not be perfectly accurate.\n# The coordinates are in terms of fractional distances along the triangle edges.\n# QAP classification adapted from Streckeisen, 1974\nclassification_regions = {\n    \"Granite\": [(0.9, 0), (0.6, 0.4), (0.6, 0.05), (0.9, 0)], #modified\n    \"Granodiorite\": [(0.6, 0.4), (0.2, 0.65), (0.2, 0.15), (0.6, 0.05)],#modified\n    \"Tonalite\": [(0.2, 0.65), (0.0, 0.85), (0.0, 0.35), (0.2, 0.15)], #modified\n    \"Syenite\": [(0.9, 0), (0.95, 0.05), (1.0,0.0), (0.9,0.0)], #modified\n    \"Monzonite\": [(0.6, 0.05), (0.55, 0.0), (0.95, 0.05), (0.6, 0.05)], #modified\n    \"Diorite\": [(0.2, 0.15), (0.0, 0.35), (0.0, 0.0), (0.2, 0.15)], #modified\n    \"Quartz-rich Granite\": [(0.9,0.0),(1.0,0.0),(0.95,0.05),(0.9,0.0)],\n    \"Quartz-rich Granodiorite\": [(0.55, 0.0), (0.6, 0.05), (0.2, 0.15), (0.0,0.0)]\n}\n\n\n# Function to convert QAP percentages to Cartesian coordinates\ndef qap_to_xy(q, a, p):\n    \"\"\"Converts QAP percentages to Cartesian coordinates within the triangle.\"\"\"\n    x = a + 0.5 * q\n    y = np.sqrt(3)/2 * q\n    return x, y\n\n# Sample data (QAP percentages)\nif 'sample_data' not in st.session_state:\n    st.session_state['sample_data'] = pd.DataFrame({\n        \"Rock\": [\"Sample 1\", \"Sample 2\", \"Sample 3\", \"Sample 4\", \"Sample 5\"],\n        \"Quartz\": [65, 55, 15, 5, 2],\n        \"Alkali Feldspar\": [25, 15, 40, 80, 20],\n        \"Plagioclase\": [10, 30, 45, 15, 78]\n    })\n\n    # Normalize the percentages to ensure they sum to 100\n    st.session_state['sample_data'][[\"Quartz\", \"Alkali Feldspar\", \"Plagioclase\"]] = st.session_state['sample_data'][[\"Quartz\", \"Alkali Feldspar\", \"Plagioclase\"]].apply(lambda x: x/x.sum()*100, axis=1)\n\n    # Convert QAP percentages to x, y coordinates\n    st.session_state['sample_data'][\"x\"], st.session_state['sample_data'][\"y\"] = zip(*st.session_state['sample_data'].apply(lambda row: qap_to_xy(row[\"Quartz\"]/100, row[\"Alkali Feldspar\"]/100, row[\"Plagioclase\"]/100), axis=1))\n\n# --- Streamlit App ---\nst.title(\"QAP Ternary Diagram for Plutonic Rock Classification\")\nst.markdown(\"This interactive diagram allows you to plot rock compositions and classify them based on their Quartz (Q), Alkali Feldspar (A), and Plagioclase (P) content.\")\n\n# Sidebar for user input\nst.sidebar.header(\"Add New Sample\")\nquartz_input = st.sidebar.slider(\"Quartz (%)\", 0, 100, 25)\nalkali_feldspar_input = st.sidebar.slider(\"Alkali Feldspar (%)\", 0, 100, 25)\nplagioclase_input = st.sidebar.slider(\"Plagioclase (%)\", 0, 100, 50)\n\n# Normalize input values\ntotal = quartz_input + alkali_feldspar_input + plagioclase_input\nif total > 0:\n    quartz_input = quartz_input / total * 100\n    alkali_feldspar_input = alkali_feldspar_input / total * 100\n    plagioclase_input = plagioclase_input / total * 100\nelse:\n    st.sidebar.warning(\"Sum of percentages must be greater than 0.\")\n\nnew_sample_name = st.sidebar.text_input(\"New Sample Name\", \"New Sample\")\n\nif st.sidebar.button(\"Add Sample\"):\n    new_x, new_y = qap_to_xy(quartz_input/100, alkali_feldspar_input/100, plagioclase_input/100)\n    new_row = pd.DataFrame({\"Rock\": [new_sample_name],\n                            \"Quartz\": [quartz_input],\n                            \"Alkali Feldspar\": [alkali_feldspar_input],\n                            \"Plagioclase\": [plagioclase_input],\n                            \"x\": [new_x],\n                            \"y\": [new_y]})\n    st.session_state['sample_data'] = pd.concat([st.session_state['sample_data'], new_row], ignore_index=True)\n\n\n# Create the plot using Plotly\nfig = go.Figure()\n\n# Add the classification regions\ncolors = [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\"]\ni=0\nfor rock_type, vertices in classification_regions.items():\n    x = [Q[0] + (A[0]-Q[0])*v[0] + (P[0]-Q[0])*v[1] for v in vertices]\n    y = [Q[1] + (A[1]-Q[1])*v[0] + (P[1]-Q[1])*v[1] for v in vertices]\n\n    fig.add_trace(go.Scatter(x=x, y=y, fill=\"toself\", mode=\"lines\", name=rock_type, fillcolor=colors[i % len(colors)], line=dict(width=0.5), opacity=0.5))\n    i+=1\n\n# Add the sample data points\nfig.add_trace(go.Scatter(x=st.session_state['sample_data'][\"x\"], y=st.session_state['sample_data'][\"y\"], mode=\"markers\", marker=dict(size=10, color=\"black\"), text=st.session_state['sample_data'][\"Rock\"], name=\"Samples\"))\n\n# Add the triangle outline\nfig.add_trace(go.Scatter(x=[Q[0], A[0], P[0], Q[0]], y=[Q[1], A[1], P[1], Q[1]], mode=\"lines\", line=dict(color=\"black\")))\n\n# Add the vertex labels\nfig.add_annotation(x=Q[0]-0.05, y=Q[1]-0.02, text=\"Q\", showarrow=False, font=dict(size=16))\nfig.add_annotation(x=A[0]+0.05, y=A[1]-0.02, text=\"A\", showarrow=False, font=dict(size=16))\nfig.add_annotation(x=P[0], y=P[1]+0.05, text=\"P\", showarrow=False, font=dict(size=16))\n\n# Customize the layout\nfig.update_layout(\n    title=\"QAP Ternary Diagram for Plutonic Rock Classification\",\n    xaxis=dict(range=[-0.1, 1.1], visible=False, fixedrange=True),\n    yaxis=dict(range=[-0.1, 1.0], visible=False, fixedrange=True),\n    showlegend=True,\n    width=800,\n    height=700,\n    margin=dict(l=0, r=0, b=0, t=50),\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)'\n)\n\n# Show the plot in Streamlit\nst.plotly_chart(fig, use_container_width=True)\n\n# Display the sample data as a table\nst.subheader(\"Sample Data\")\nst.dataframe(st.session_state['sample_data'])",
    "title": "Plutonic Rock Classification: QAP Ternary Diagram",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "f2929a9d-6845-4a6f-9959-32a1532989bf": {
    "id": "f2929a9d-6845-4a6f-9959-32a1532989bf",
    "created_at": "2025-04-17T13:51:27.494409",
    "updated_at": "2025-04-17T13:53:21.268355",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Suppress warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# QAP Ternary Diagram for Plutonic Rock Classification\n\n# Define rock type regions more accurately based on Streckeisen classification\ndef add_rock_type_regions(fig):\n    # Granite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [10, 35, 65, 90, 90],\n        'b': [10, 10, 10, 10, 0],\n        'c': [80, 55, 25, 0, 10],\n        'text': ['', '', 'Granite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Granite',\n        'line': {'color': 'rgba(255, 0, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(255, 0, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Granodiorite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [10, 10, 35, 10],\n        'b': [40, 10, 10, 40],\n        'c': [50, 80, 55, 50],\n        'text': ['', '', 'Granodiorite', ''],\n        'textposition': 'middle center',\n        'name': 'Granodiorite',\n        'line': {'color': 'rgba(0, 255, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(0, 255, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Tonalite (Quartz Diorite)\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [10, 10, 0, 0, 10],\n        'b': [65, 40, 40, 65, 65],\n        'c': [25, 50, 60, 35, 25],\n        'text': ['', '', 'Tonalite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Tonalite',\n        'line': {'color': 'rgba(0, 0, 255, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(0, 0, 255, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Syenite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [65, 90, 90, 65, 65],\n        'b': [35, 10, 0, 0, 35],\n        'c': [0, 0, 10, 35, 0],\n        'text': ['', '', 'Syenite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Syenite',\n        'line': {'color': 'rgba(255, 255, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(255, 255, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Monzonite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [35, 65, 65, 35, 35],\n        'b': [65, 35, 0, 0, 65],\n        'c': [0, 0, 35, 65, 0],\n        'text': ['', '', 'Monzonite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Monzonite',\n        'line': {'color': 'rgba(255, 0, 255, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(255, 0, 255, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Diorite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [0, 35, 35, 0, 0],\n        'b': [100, 65, 0, 0, 100],\n        'c': [0, 0, 65, 100, 0],\n        'text': ['', '', 'Diorite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Diorite',\n        'line': {'color': 'rgba(0, 255, 255, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(0, 255, 255, 0.2)',\n        'showlegend': True\n    }))\n    \n    # Quartz Monzonite\n    fig.add_trace(go.Scatterternary({\n        'mode': 'lines+text',\n        'a': [35, 65, 65, 35, 35],\n        'b': [10, 10, 0, 0, 10],\n        'c': [55, 25, 35, 65, 55],\n        'text': ['', '', 'Quartz<br>Monzonite', '', ''],\n        'textposition': 'middle center',\n        'name': 'Quartz Monzonite',\n        'line': {'color': 'rgba(128, 128, 0, 0.5)'},\n        'fill': 'toself',\n        'fillcolor': 'rgba(128, 128, 0, 0.2)',\n        'showlegend': True\n    }))\n    \n    return fig\n\n# Sample Data (QAP values as percentages)\nsample_data = pd.DataFrame({\n    'Rock Name': ['Granite', 'Granodiorite', 'Tonalite', 'Syenite', 'Monzonite', 'Diorite', 'Quartz Monzonite', 'Quartz Diorite'],\n    'Q': [30, 20, 10, 5, 5, 0, 20, 15],\n    'A': [30, 20, 10, 60, 30, 10, 20, 5],\n    'P': [40, 60, 80, 35, 65, 90, 60, 80]\n})\n\n# Normalize to ensure Q+A+P = 100 for each row\nfor index, row in sample_data.iterrows():\n    total = row['Q'] + row['A'] + row['P']\n    sample_data.loc[index, 'Q'] = (row['Q'] / total) * 100\n    sample_data.loc[index, 'A'] = (row['A'] / total) * 100\n    sample_data.loc[index, 'P'] = (row['P'] / total) * 100\n\n# Main content\nst.title(\"QAP Ternary Diagram for Plutonic Rock Classification\")\nst.write(\"This diagram is based on the Streckeisen classification for plutonic igneous rocks.\")\n\n# User input for new data points\nst.sidebar.header(\"Add Sample Data\")\nnew_rock_name = st.sidebar.text_input(\"Rock Name\", \"New Rock\")\nnew_q = st.sidebar.number_input(\"Quartz (%)\", min_value=0.0, max_value=100.0, value=25.0, step=0.1)\nnew_a = st.sidebar.number_input(\"Alkali Feldspar (%)\", min_value=0.0, max_value=100.0, value=25.0, step=0.1)\nnew_p = st.sidebar.number_input(\"Plagioclase (%)\", min_value=0.0, max_value=100.0, value=50.0, step=0.1)\n\n# Calculate total to show user\ntotal = new_q + new_a + new_p\nst.sidebar.write(f\"Total: {total:.1f}% (will be normalized to 100%)\")\n\nif st.sidebar.button(\"Add Rock\"):\n    # Normalize to 100%\n    total = new_q + new_a + new_p\n    new_q = (new_q / total) * 100\n    new_a = (new_a / total) * 100\n    new_p = (new_p / total) * 100\n    \n    # Add to dataframe\n    new_row = pd.DataFrame({'Rock Name': [new_rock_name], 'Q': [new_q], 'A': [new_a], 'P': [new_p]})\n    sample_data = pd.concat([sample_data, new_row], ignore_index=True)\n    st.rerun()\n\n# Color options\nst.sidebar.header(\"Plot Options\")\nuse_rock_type_regions = st.sidebar.checkbox(\"Show Rock Type Fields\", value=True)\nshow_legend = st.sidebar.checkbox(\"Show Legend\", value=True)\n\n# Create ternary plot\nfig = go.Figure()\n\n# Add rock type regions if selected\nif use_rock_type_regions:\n    fig = add_rock_type_regions(fig)\n\n# Add data points\nfig.add_trace(go.Scatterternary({\n    'mode': 'markers+text',\n    'a': sample_data['A'],\n    'b': sample_data['P'], \n    'c': sample_data['Q'],\n    'text': sample_data['Rock Name'],\n    'name': 'Samples',\n    'marker': {\n        'symbol': 'circle',\n        'size': 10,\n        'color': 'black',\n        'line': {'width': 1, 'color': 'white'}\n    },\n    'textposition': 'top center'\n}))\n\n# Configure ternary axes\nfig.update_layout({\n    'ternary': {\n        'sum': 100,\n        'aaxis': {'title': 'Alkali Feldspar (A)', 'min': 0, 'linewidth': 2, 'ticksuffix': '%', 'tickfont': {'size': 12}},\n        'baxis': {'title': 'Plagioclase (P)', 'min': 0, 'linewidth': 2, 'ticksuffix': '%', 'tickfont': {'size': 12}},\n        'caxis': {'title': 'Quartz (Q)', 'min': 0, 'linewidth': 2, 'ticksuffix': '%', 'tickfont': {'size': 12}}\n    },\n    'showlegend': show_legend,\n    'height': 700,\n    'width': 800,\n    'margin': {'l': 50, 'r': 50, 'b': 50, 't': 50}\n})\n\n# Display the ternary plot\nst.plotly_chart(fig, use_container_width=True)\n\n# Add explanation\nst.subheader(\"About QAP Diagrams\")\nst.write(\"\"\"\nThe QAP diagram is a ternary plot used by geologists to classify plutonic igneous rocks based on their mineral composition. \nThe three vertices represent:\n- **Q**: Quartz\n- **A**: Alkali feldspar (orthoclase, microcline, etc.)\n- **P**: Plagioclase feldspar\n\nThis classification system, developed by Albert Streckeisen, is widely used in petrography and igneous petrology.\n\"\"\")\n\n# Display the sample data table with formatting\nst.subheader(\"Sample Data Table\")\nst.dataframe(sample_data.style.format({'Q': '{:.1f}%', 'A': '{:.1f}%', 'P': '{:.1f}%'}), hide_index=True)\n\n# Add download option for the data\ncsv = sample_data.to_csv(index=False)\nst.download_button(\n    label=\"Download Data as CSV\",\n    data=csv,\n    file_name=\"qap_data.csv\",\n    mime=\"text/csv\"\n)",
    "title": "Plutonic Rock Classification: QAP Ternary Diagram",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "8c9889f2-db78-4543-8647-8f94c36b6262": {
    "id": "8c9889f2-db78-4543-8647-8f94c36b6262",
    "created_at": "2025-04-17T13:58:45.709628",
    "updated_at": "2025-04-17T13:59:04.447962",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Interactive Piper Diagram for Hydrogeochemical Analysis\")\n\n# Explanation of Piper Diagram\nst.markdown(\"\"\"\n## Understanding Piper Diagrams\n\nPiper diagrams are graphical representations used in hydrogeochemistry to visualize and classify water samples based on their major ion chemistry. They consist of three main components:\n\n*   **Cation Triangle:** Represents the relative proportions of major cations (Ca\u00b2\u207a, Mg\u00b2\u207a, Na\u207a+K\u207a).\n*   **Anion Triangle:** Represents the relative proportions of major anions (HCO\u2083\u207b+CO\u2083\u00b2\u207b, SO\u2084\u00b2\u207b, Cl\u207b).\n*   **Central Diamond:** Projects the data from the two triangles to show overall water type.\n\nThe position of a sample within these plots provides insights into its geochemical characteristics and origin. Different regions of the diamond plot correspond to different water types (e.g., Ca-HCO\u2083, Na-Cl).\n\nThis tool allows you to interactively explore Piper diagrams and classify water samples based on their ion concentrations. You can input your own data and visualize how it compares to common water types.\n\"\"\")\n\n# Sample Data\nsample_data = {\n    'Sample': ['Freshwater 1', 'Freshwater 2', 'Seawater', 'Brine', 'Groundwater 1', 'Groundwater 2'],\n    'Ca': [1.5, 2.0, 0.4, 0.1, 1.8, 0.5],\n    'Mg': [0.5, 0.8, 0.1, 0.05, 0.7, 0.2],\n    'Na': [0.3, 0.5, 4.7, 6.0, 0.4, 5.0],\n    'K': [0.1, 0.05, 0.1, 0.2, 0.05, 0.1],\n    'HCO3': [2.5, 3.0, 0.1, 0.05, 2.8, 0.3],\n    'SO4': [0.4, 0.6, 0.3, 1.5, 0.5, 2.0],\n    'Cl': [0.2, 0.3, 5.5, 7.0, 0.3, 6.0],\n    'Water Type': ['Freshwater', 'Freshwater', 'Seawater', 'Brine', 'Freshwater', 'Brine']\n}\ndf = pd.DataFrame(sample_data)\n\n# Sidebar for User Input\nst.sidebar.header(\"Input New Water Sample\")\nnew_sample_name = st.sidebar.text_input(\"Sample Name\", \"New Sample\")\nnew_ca = st.sidebar.number_input(\"Ca\u00b2\u207a (meq/L)\", value=1.0)\nnew_mg = st.sidebar.number_input(\"Mg\u00b2\u207a (meq/L)\", value=0.5)\nnew_na = st.sidebar.number_input(\"Na\u207a (meq/L)\", value=0.3)\nnew_k = st.sidebar.number_input(\"K\u207a (meq/L)\", value=0.1)\nnew_hco3 = st.sidebar.number_input(\"HCO\u2083\u207b (meq/L)\", value=2.5)\nnew_so4 = st.sidebar.number_input(\"SO\u2084\u00b2\u207b (meq/L)\", value=0.4)\nnew_cl = st.sidebar.number_input(\"Cl\u207b (meq/L)\", value=0.2)\nnew_water_type = st.sidebar.text_input(\"Water Type\", \"User Defined\")\n\nif st.sidebar.button(\"Add Sample\"):\n    new_row = {\n        'Sample': new_sample_name,\n        'Ca': new_ca,\n        'Mg': new_mg,\n        'Na': new_na,\n        'K': new_k,\n        'HCO3': new_hco3,\n        'SO4': new_so4,\n        'Cl': new_cl,\n        'Water Type': new_water_type\n    }\n    df = pd.concat([df, pd.DataFrame(new_row, index=[0])], ignore_index=True)\n    st.rerun()\n\n# Normalization function\ndef normalize_ions(row):\n    cations_sum = row['Ca'] + row['Mg'] + row['Na'] + row['K']\n    anions_sum = row['HCO3'] + row['SO4'] + row['Cl']\n\n    row['Ca_percent'] = (row['Ca'] / cations_sum) * 100\n    row['Mg_percent'] = (row['Mg'] / cations_sum) * 100\n    row['NaK_percent'] = ((row['Na'] + row['K']) / cations_sum) * 100\n\n    row['HCO3_percent'] = (row['HCO3'] / anions_sum) * 100\n    row['SO4_percent'] = (row['SO4'] / anions_sum) * 100\n    row['Cl_percent'] = (row['Cl'] / anions_sum) * 100\n    return row\n\ndf = df.apply(normalize_ions, axis=1)\n\n# Cation Triangle Data\ncation_data = df[['Sample', 'Ca_percent', 'Mg_percent', 'NaK_percent', 'Water Type']]\ncation_data = cation_data.rename(columns={'Ca_percent': 'Ca', 'Mg_percent': 'Mg', 'NaK_percent': 'NaK'})\n\n# Anion Triangle Data\nanion_data = df[['Sample', 'HCO3_percent', 'SO4_percent', 'Cl_percent', 'Water Type']]\nanion_data = anion_data.rename(columns={'HCO3_percent': 'HCO3', 'SO4_percent': 'SO4', 'Cl_percent': 'Cl'})\n\n# Diamond Data (Piper Plot) - Simplified calculation\ndf['CaNa'] = df['Ca_percent'] - df['NaK_percent']\ndf['MgK'] = df['Mg_percent'] - df['NaK_percent']\ndf['HCO3Cl'] = df['HCO3_percent'] - df['Cl_percent']\ndf['SO4Cl'] = df['SO4_percent'] - df['Cl_percent']\n\ndf['diamond_x'] = (df['CaNa'] + df['HCO3Cl']) / 2\ndf['diamond_y'] = (df['MgK'] + df['SO4Cl']) / 2 * (np.sqrt(3)/2)\n\n# Water Type Filtering\nwater_type_options = df['Water Type'].unique().tolist()\nselected_water_types = st.multiselect(\"Select Water Types to Display\", water_type_options, default=water_type_options)\nfiltered_df = df[df['Water Type'].isin(selected_water_types)]\n\n# Create Piper Diagram using Plotly\nfig = go.Figure()\n\n# Cation Triangle\nfig.add_trace(go.Scatter(\n    x=filtered_df['Ca_percent'],\n    y=filtered_df['Mg_percent'],\n    mode='markers',\n    marker=dict(size=10, color=filtered_df['Water Type'], line=dict(width=0.5, color='Black')),\n    name='Cations',\n    text=[f\"Sample: {row['Sample']}<br>Ca: {row['Ca_percent']:.2f}%<br>Mg: {row['Mg_percent']:.2f}%<br>Na+K: {row['NaK_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\"\n))\n\n# Anion Triangle\nfig.add_trace(go.Scatter(\n    x=[x + 100 for x in filtered_df['HCO3_percent']],\n    y=filtered_df['SO4_percent'],\n    mode='markers',\n    marker=dict(size=10, color=filtered_df['Water Type'], line=dict(width=0.5, color='Black')),\n    name='Anions',\n    text=[f\"Sample: {row['Sample']}<br>HCO3: {row['HCO3_percent']:.2f}%<br>SO4: {row['SO4_percent']:.2f}%<br>Cl: {row['Cl_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\"\n))\n\n# Diamond Plot\nfig.add_trace(go.Scatter(\n    x=[x + 50 for x in filtered_df['diamond_x']],\n    y=filtered_df['diamond_y'],\n    mode='markers',\n    marker=dict(size=10, color=filtered_df['Water Type'], line=dict(width=0.5, color='Black')),\n    name='Diamond',\n    text=[f\"Sample: {row['Sample']}<br>Diamond X: {row['diamond_x']:.2f}<br>Diamond Y: {row['diamond_y']:.2f}\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\"\n))\n\n# Layout\nfig.update_layout(\n    title='Piper Diagram',\n    xaxis=dict(range=[-10, 210], showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(range=[-10, 100], showgrid=False, zeroline=False, showticklabels=False),\n    shapes=[\n        # Cation Triangle\n        dict(type=\"line\", x0=0, y0=0, x1=50, y1=86.6, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=50, y0=86.6, x1=100, y0=0, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=0, y0=0, x1=100, y0=0, line=dict(color=\"Black\", width=1)),\n        # Anion Triangle\n        dict(type=\"line\", x0=100, y0=0, x1=150, y1=86.6, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=150, y0=86.6, x1=200, y0=0, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=100, y0=0, x1=200, y0=0, line=dict(color=\"Black\", width=1)),\n        # Diamond\n        dict(type=\"line\", x0=50, y0=86.6, x1=150, y1=86.6, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=50, y0=86.6, x1=100, y0=0, line=dict(color=\"Black\", width=1)),\n        dict(type=\"line\", x0=150, y0=86.6, x1=100, y0=0, line=dict(color=\"Black\", width=1))\n    ],\n    annotations=[\n        # Cation Triangle Labels\n        dict(x=50, y=90, text='Mg\u00b2\u207a', showarrow=False),\n        dict(x=0, y=-5, text='Ca\u00b2\u207a', showarrow=False),\n        dict(x=100, y=-5, text='Na\u207a+K\u207a', showarrow=False),\n        # Anion Triangle Labels\n        dict(x=150, y=90, text='SO\u2084\u00b2\u207b', showarrow=False),\n        dict(x=100, y=-5, text='HCO\u2083\u207b+CO\u2083\u00b2\u207b', showarrow=False),\n        dict(x=200, y=-5, text='Cl\u207b', showarrow=False),\n        # Diamond Labels (simplified)\n        dict(x=75, y=43.3, text='Ca-HCO\u2083', showarrow=False),\n        dict(x=125, y=43.3, text='Na-Cl', showarrow=False),\n    ]\n)\n\nst.plotly_chart(fig, use_container_width=True)\n\n# Data Table\nst.header(\"Sample Data Table\")\nst.dataframe(df)",
    "title": "Interactive Piper Diagram for Water Chemistry Analysis",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "6988cad2-00bc-4cd5-beb1-7fea51bcb6e3": {
    "id": "6988cad2-00bc-4cd5-beb1-7fea51bcb6e3",
    "created_at": "2025-04-17T13:59:49.618492",
    "updated_at": "2025-04-17T14:07:37.697562",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Suppress warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# --- Introduction to Piper Diagrams ---\nst.title(\"Interactive Piper Diagram for Hydrogeochemical Analysis\")\n\nst.markdown(\"\"\"\n**What is a Piper Diagram?**\n\nA Piper diagram is a graphical representation used in hydrogeochemistry to visualize and classify water samples based on their major ion chemistry. It consists of three parts: two triangles representing the cation and anion compositions, and a central diamond field where the water types are classified.\n\n**How to Interpret a Piper Diagram:**\n\n1. **Triangles:** The cation triangle plots the relative percentages of major cations (Calcium, Magnesium, Sodium + Potassium), while the anion triangle plots the relative percentages of major anions (Bicarbonate + Carbonate, Sulfate, Chloride).\n2. **Diamond Field:** The data points from the triangles are projected onto the diamond field, which helps in classifying the water type based on the dominant ions. The diamond plot shows the combined cation and anion facies, allowing for a comprehensive understanding of the water's geochemical character.\n3. **Water Types:** Different regions of the diamond field represent different water types (e.g., Calcium-Bicarbonate, Sodium-Chloride). The position of a sample in the diamond indicates its dominant ion composition and potential origin.\n\n**Use:**\n\nPiper diagrams are useful for understanding groundwater evolution, water-rock interactions, and mixing processes. By visualizing the relative concentrations of major ions, we can infer the source of the water, the geological formations it has interacted with, and the processes that have altered its chemical composition.\n\"\"\")\n\n# --- Sample Data ---\n# Sample data for common water types (meq/L)\ndata = {\n    'Sample': ['Freshwater 1', 'Freshwater 2', 'Seawater', 'Brine', 'Acid Mine Drainage', 'Limestone Aquifer', 'Granite Aquifer'],\n    'Ca': [1.5, 2.0, 10.5, 50.0, 25.0, 4.0, 0.5],\n    'Mg': [0.5, 1.0, 52.0, 150.0, 10.0, 1.0, 0.2],\n    'Na': [1.0, 1.5, 450.0, 1000.0, 5.0, 0.5, 3.0],\n    'K': [0.2, 0.3, 10.0, 20.0, 1.0, 0.1, 0.1],\n    'HCO3': [2.5, 3.0, 20.0, 5.0, 0.1, 5.0, 1.0],\n    'SO4': [0.5, 1.0, 25.0, 500.0, 50.0, 0.2, 1.5],\n    'Cl': [0.2, 0.5, 500.0, 1500.0, 10.0, 0.1, 0.5],\n    'Water Type': ['Freshwater', 'Freshwater', 'Seawater', 'Brine', 'Acid Mine Drainage', 'Limestone', 'Granite']\n}\ndf = pd.DataFrame(data)\n\n# Create a color map for water types\nall_water_types = df['Water Type'].unique()\nwater_type_colors = {\n    water_type: f\"hsl({i * 360 // len(all_water_types)}, 70%, 50%)\" \n    for i, water_type in enumerate(all_water_types)\n}\n\n# --- Sidebar for User Input ---\nst.sidebar.header(\"Input New Water Sample Data\")\nsample_name = st.sidebar.text_input(\"Sample Name\", \"New Sample\")\nca_input = st.sidebar.number_input(\"Ca\u00b2\u207a (meq/L)\", value=2.0, min_value=0.0, format=\"%.2f\")\nmg_input = st.sidebar.number_input(\"Mg\u00b2\u207a (meq/L)\", value=1.0, min_value=0.0, format=\"%.2f\")\nna_input = st.sidebar.number_input(\"Na\u207a (meq/L)\", value=1.5, min_value=0.0, format=\"%.2f\")\nk_input = st.sidebar.number_input(\"K\u207a (meq/L)\", value=0.3, min_value=0.0, format=\"%.2f\")\nhco3_input = st.sidebar.number_input(\"HCO\u2083\u207b (meq/L)\", value=3.0, min_value=0.0, format=\"%.2f\")\nso4_input = st.sidebar.number_input(\"SO\u2084\u00b2\u207b (meq/L)\", value=1.0, min_value=0.0, format=\"%.2f\")\ncl_input = st.sidebar.number_input(\"Cl\u207b (meq/L)\", value=0.5, min_value=0.0, format=\"%.2f\")\nwater_type_input = st.sidebar.selectbox(\"Water Type\", [\"Unknown\"] + list(all_water_types))\n\n# Check if inputs are valid\ninput_valid = True\nerror_message = \"\"\n\nif (ca_input + mg_input + na_input + k_input) == 0:\n    input_valid = False\n    error_message += \"Total cations must be greater than 0. \"\n\nif (hco3_input + so4_input + cl_input) == 0:\n    input_valid = False\n    error_message += \"Total anions must be greater than 0.\"\n\nif not input_valid:\n    st.sidebar.error(error_message)\n\n# Add new sample data to dataframe\nif st.sidebar.button(\"Add Sample\") and input_valid:\n    new_sample = {\n        'Sample': sample_name,\n        'Ca': ca_input,\n        'Mg': mg_input,\n        'Na': na_input,\n        'K': k_input,\n        'HCO3': hco3_input,\n        'SO4': so4_input,\n        'Cl': cl_input,\n        'Water Type': water_type_input\n    }\n    df = pd.concat([df, pd.DataFrame([new_sample])], ignore_index=True)\n    \n    # Update color map if new water type\n    if water_type_input not in water_type_colors and water_type_input != \"Unknown\":\n        all_water_types = df['Water Type'].unique() # Update all_water_types\n        water_type_colors[water_type_input] = f\"hsl({len(water_type_colors) * 360 // (len(all_water_types))}, 70%, 50%)\"\n    \n    st.success(f\"Added sample: {sample_name}\")\n    st.rerun()\n\n# --- Normalize Ion Concentrations ---\ndef normalize_ions(df):\n    # Create a copy to avoid warning\n    result = df.copy()\n    \n    # Calculate sum of cations and anions for each row\n    result['cations_sum'] = result['Ca'] + result['Mg'] + result['Na'] + result['K']\n    result['anions_sum'] = result['HCO3'] + result['SO4'] + result['Cl']\n    \n    # Calculate percentages\n    result['Ca_percent'] = (result['Ca'] / result['cations_sum']) * 100\n    result['Mg_percent'] = (result['Mg'] / result['cations_sum']) * 100\n    result['NaK_percent'] = ((result['Na'] + result['K']) / result['cations_sum']) * 100\n    \n    result['HCO3_percent'] = (result['HCO3'] / result['anions_sum']) * 100\n    result['SO4_percent'] = (result['SO4'] / result['anions_sum']) * 100\n    result['Cl_percent'] = (result['Cl'] / result['anions_sum']) * 100\n    \n    return result\n\n# Apply normalization\nnormalized_df = normalize_ions(df)\n\n# --- Functions to convert percentages to plotting coordinates ---\ndef get_cation_coordinates(row):\n    # For cation triangle\n    x = 100 - row['NaK_percent']  # Ca side is at 100%, Na+K at 0%\n    y = row['Mg_percent'] * np.sqrt(3) / 2  # Height of equilateral triangle\n    return x, y\n\ndef get_anion_coordinates(row):\n    # For anion triangle (offset to the right)\n    x = 100 + row['Cl_percent']  # HCO3 side is at 100%, Cl at 200%\n    y = row['SO4_percent'] * np.sqrt(3) / 2\n    return x, y\n\ndef get_diamond_coordinates(row):\n    # Project points to the diamond\n    cation_x, cation_y = get_cation_coordinates(row)\n    anion_x, anion_y = get_anion_coordinates(row)\n    \n    # Diamond coordinates (simple average of the triangles)\n    x = (cation_x + anion_x) / 2\n    y = (cation_y + anion_y) / 2\n    return x, y\n\n# --- Piper Diagram Plotting ---\ndef create_piper_diagram(df, color_by='Water Type'):\n    fig = go.Figure()\n    \n    # Create coordinate lists\n    cation_x = []\n    cation_y = []\n    anion_x = []\n    anion_y = []\n    diamond_x = []\n    diamond_y = []\n    \n    for _, row in df.iterrows():\n        # Calculate coordinates for each sample\n        cx, cy = get_cation_coordinates(row)\n        ax, ay = get_anion_coordinates(row)\n        dx, dy = get_diamond_coordinates(row)\n        \n        cation_x.append(cx)\n        cation_y.append(cy)\n        anion_x.append(ax)\n        anion_y.append(ay)\n        diamond_x.append(dx)\n        diamond_y.append(dy)\n    \n    # Set colors based on selected option\n    if color_by == 'Water Type':\n        colors = [water_type_colors.get(wt, \"gray\") for wt in df['Water Type']]\n    else:  # Sample name\n        import plotly.express as px\n        colors = px.colors.qualitative.Plotly[:len(df)]\n    \n    # Add the three sets of points\n    for point_type, x, y in [\n        (\"Cations\", cation_x, cation_y),\n        (\"Anions\", anion_x, anion_y),\n        (\"Diamond\", diamond_x, diamond_y)\n    ]:\n        name = point_type\n        showlegend = (point_type == \"Diamond\")  # Only show legend for diamond points\n        \n        hover_text = []\n        for i, row in df.iterrows():\n            hover_text.append(\n                f\"Sample: {row['Sample']}<br>\"\n                f\"Water Type: {row['Water Type']}<br>\"\n                f\"Ca: {row['Ca_percent']:.1f}%<br>\"\n                f\"Mg: {row['Mg_percent']:.1f}%<br>\"\n                f\"Na+K: {row['NaK_percent']:.1f}%<br>\"\n                f\"HCO\u2083: {row['HCO3_percent']:.1f}%<br>\"\n                f\"SO\u2084: {row['SO4_percent']:.1f}%<br>\"\n                f\"Cl: {row['Cl_percent']:.1f}%\"\n            )\n            \n        fig.add_trace(go.Scatter(\n            x=x,\n            y=y,\n            mode='markers',\n            marker=dict(\n                color=colors,\n                size=10,\n                line=dict(width=1, color='Black')\n            ),\n            text=hover_text,\n            hovertemplate=\"%{text}<extra></extra>\",\n            name=name if showlegend else None,\n            showlegend=showlegend,\n            legendgroup=\"samples\"\n        ))\n    \n    # Add water type legend\n    if color_by == 'Water Type':\n        for water_type, color in water_type_colors.items():\n            fig.add_trace(go.Scatter(\n                x=[None], y=[None],  # No data points, just for legend\n                mode='markers',\n                marker=dict(color=color, size=10),\n                name=water_type\n            ))\n    \n    # Define triangle and diamond boundaries\n    # Cation triangle\n    fig.add_trace(go.Scatter(\n        x=[0, 100, 50, 0],\n        y=[0, 0, 86.6, 0],\n        mode='lines',\n        line=dict(color='black', width=2),\n        fill=None,\n        name='Cation Triangle',\n        showlegend=False\n    ))\n    \n    # Anion triangle\n    fig.add_trace(go.Scatter(\n        x=[100, 200, 150, 100],\n        y=[0, 0, 86.6, 0],\n        mode='lines',\n        line=dict(color='black', width=2),\n        fill=None,\n        name='Anion Triangle',\n        showlegend=False\n    ))\n    \n    # Diamond\n    fig.add_trace(go.Scatter(\n        x=[50, 100, 150, 100, 50],\n        y=[86.6, 173.2, 86.6, 0, 86.6],\n        mode='lines',\n        line=dict(color='black', width=2),\n        fill=None,\n        name='Diamond',\n        showlegend=False\n    ))\n    \n    # Add grid lines within triangles and labels\n    # Grid lines in cation triangle\n    for i in range(20, 100, 20):\n        # Lines parallel to base\n        fig.add_trace(go.Scatter(\n            x=[i/2, 100-i/2],\n            y=[i*np.sqrt(3)/2, i*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from left vertex\n        fig.add_trace(go.Scatter(\n            x=[i, 50+(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from right vertex\n        fig.add_trace(go.Scatter(\n            x=[100-i, 50-(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n    \n    # Identical grid lines for anion triangle (shifted)\n    for i in range(20, 100, 20):\n        # Lines parallel to base\n        fig.add_trace(go.Scatter(\n            x=[100+i/2, 200-i/2],\n            y=[i*np.sqrt(3)/2, i*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from left vertex\n        fig.add_trace(go.Scatter(\n            x=[100+i, 150+(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n        # Lines from right vertex\n        fig.add_trace(go.Scatter(\n            x=[200-i, 150-(50-i)/2],\n            y=[0, (50-i)*np.sqrt(3)/2],\n            mode='lines',\n            line=dict(color='gray', width=1, dash='dot'),\n            showlegend=False\n        ))\n    \n    # Add labels\n    annotations = [\n        # Cation Triangle\n        dict(x=0, y=-5, text=\"Ca\u00b2\u207a 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=100, y=-5, text=\"Na\u207a+K\u207a 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=50, y=90, text=\"Mg\u00b2\u207a 100%\", showarrow=False, font=dict(size=12)),\n        \n        # Anion Triangle\n        dict(x=100, y=-5, text=\"HCO\u2083\u207b+CO\u2083\u00b2\u207b 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=200, y=-5, text=\"Cl\u207b 100%\", showarrow=False, font=dict(size=12)),\n        dict(x=150, y=90, text=\"SO\u2084\u00b2\u207b 100%\", showarrow=False, font=dict(size=12)),\n        \n        # Diamond Water Types\n        dict(x=50, y=40, text=\"Ca-HCO\u2083\", showarrow=False, font=dict(size=10)),\n        dict(x=150, y=40, text=\"Na-Cl\", showarrow=False, font=dict(size=10)),\n        dict(x=100, y=140, text=\"Ca/Mg-SO\u2084\", showarrow=False, font=dict(size=10)),\n        dict(x=100, y=20, text=\"Na-HCO\u2083\", showarrow=False, font=dict(size=10)),\n    ]\n    \n    # Layout configuration\n    fig.update_layout(\n        title=\"Piper Diagram\",\n        height=700,\n        width=1000,\n        xaxis=dict(\n            showgrid=False,\n            zeroline=False,\n            showticklabels=False,\n            range=[-10, 210]\n        ),\n        yaxis=dict(\n            showgrid=False,\n            zeroline=False,\n            showticklabels=False,\n            range=[-10, 190],\n            scaleanchor=\"x\",\n            scaleratio=1  # Keep aspect ratio 1:1\n        ),\n        annotations=annotations,\n        plot_bgcolor='rgba(240,240,240,0.8)'\n    )\n    \n    return fig\n\n# --- Toggle Sample Groups ---\nst.markdown(\"## Sample Visualization\")\ncol1, col2 = st.columns(2)\n\nwith col1:\n    unique_water_types = df['Water Type'].unique().tolist()\n    selected_water_types = st.multiselect(\n        \"Select Water Types to Display\", \n        unique_water_types, \n        default=unique_water_types\n    )\n\nwith col2:\n    color_option = st.radio(\"Color Points By\", ['Water Type', 'Sample'])\n\n# Filter data based on selection\nfiltered_df = normalized_df[normalized_df['Water Type'].isin(selected_water_types)]\n\n# Create and display the diagram\nif not filtered_df.empty:\n    fig = create_piper_diagram(filtered_df, color_by=color_option)\n    st.plotly_chart(fig, use_container_width=True)\nelse:\n    st.warning(\"No data to display. Please select at least one water type.\")\n\n# --- Data Tables ---\nst.markdown(\"## Data Tables\")\ntab1, tab2 = st.tabs([\"Original Data (meq/L)\", \"Normalized Data (%)\"])\n\nwith tab1:\n    st.dataframe(df.style.format({\n        'Ca': '{:.2f}',\n        'Mg': '{:.2f}',\n        'Na': '{:.2f}',\n        'K': '{:.2f}',\n        'HCO3': '{:.2f}',\n        'SO4': '{:.2f}',\n        'Cl': '{:.2f}'\n    }))\n\nwith tab2:\n    display_cols = ['Sample', 'Water Type', 'Ca_percent', 'Mg_percent', 'NaK_percent', \n                    'HCO3_percent', 'SO4_percent', 'Cl_percent']\n    st.dataframe(normalized_df[display_cols].style.format({\n        'Ca_percent': '{:.1f}%',\n        'Mg_percent': '{:.1f}%',\n        'NaK_percent': '{:.1f}%',\n        'HCO3_percent': '{:.1f}%',\n        'SO4_percent': '{:.1f}%',\n        'Cl_percent': '{:.1f}%'\n    }))\n\n# --- Download Options ---\nst.markdown(\"## Download Data\")\ncol1, col2 = st.columns(2)\n\nwith col1:\n    csv_original = df.to_csv(index=False)\n    st.download_button(\n        label=\"Download Original Data (CSV)\",\n        data=csv_original,\n        file_name=\"piper_diagram_data.csv\",\n        mime=\"text/csv\"\n    )\n\nwith col2:\n    csv_normalized = normalized_df.to_csv(index=False)\n    st.download_button(\n        label=\"Download Normalized Data (CSV)\",\n        data=csv_normalized,\n        file_name=\"piper_diagram_normalized_data.csv\",\n        mime=\"text/csv\"\n    )\n\n# --- Interpretation Guidance ---\nst.markdown(\"## Interpreting the Piper Diagram\")\nst.write(\"\"\"\nBy observing where the water samples plot on the Piper diagram, you can infer their dominant ion chemistry and potential origins.\n\n*   **Ca-HCO\u2083 type:** Typically found in shallow groundwater systems interacting with carbonate rocks like limestone. This water is usually fresh and reflects recently recharged groundwater.\n\n*   **Na-Cl type:** Often associated with seawater intrusion, saline aquifers, or dissolution of halite deposits. This water type is common in deep basins, connate water, and areas affected by evaporation.\n\n*   **Ca/Mg-SO\u2084 type:** May indicate interaction with dolomitic rocks or evaporite deposits containing gypsum or anhydrite. Also common in areas affected by acid mine drainage or pyrite oxidation.\n\n*   **Na-HCO\u2083 type:** Often results from ion exchange processes where calcium in groundwater is exchanged for sodium in clay minerals. This water type is common in deeper, more evolved groundwater systems.\n\n*   **Mixed type:** Represents waters with no clear dominance of specific ion combinations, indicating mixing of different water sources or complex geochemical processes.\n\nThe water samples' position on the diagram can also indicate:\n\n* **Evolutionary trends:** Samples often follow a path from Ca-HCO\u2083 \u2192 Na-HCO\u2083 \u2192 Na-Cl as they evolve along a flowpath\n* **Mixing lines:** Linear arrangements of points between two end-members may indicate mixing of different water sources\n* **Contamination:** Unusual positions or shifts can indicate anthropogenic impacts\n\"\"\")\n\n# Add references\nst.markdown(\"## References\")\nst.markdown(\"\"\"\n1. Piper, A.M., 1944. A graphic procedure in the geochemical interpretation of water-analyses. Transactions, American Geophysical Union, 25(6), pp.914-928.\n2. Freeze, R.A. and Cherry, J.A., 1979. Groundwater. Prentice-Hall, Inc., Englewood Cliffs, NJ.\n3. Hem, J.D., 1985. Study and interpretation of the chemical characteristics of natural water (Vol. 2254). Department of the Interior, US Geological Survey.\n\"\"\")",
    "title": "Interactive Piper Diagram for Water Geochemistry",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "003306f7-7d7c-45e8-8ff7-d9266b207997": {
    "id": "003306f7-7d7c-45e8-8ff7-d9266b207997",
    "created_at": "2025-04-17T14:08:01.448324",
    "updated_at": "2025-04-17T14:08:37.697603",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nst.title(\"Interactive Piper Diagram\")\n\nst.markdown(\"\"\"\nA Piper diagram is a graphical representation of the major ion chemistry of water samples. It is used to classify and compare water samples, understand their geochemical evolution, and infer water-rock interactions.\n\n**How to Interpret:**\n\n*   **Triangles:** Represent the percentage composition of major cations (Ca2+, Mg2+, Na+ + K+) and anions (HCO3- + CO32-, SO42-, Cl-).\n*   **Diamond:** Projects the data from the triangles to show overall water type classification (e.g., Ca-HCO3 type, Na-Cl type).  The central diamond is key for classifying water types.\n*   **Data Trends:**  The position of data points reveals trends in water chemistry, indicating mixing, weathering, or other geochemical processes. For example, waters evolving from fresh to saline conditions often migrate from the Ca-HCO3 region towards the Na-Cl region.\n\n\"\"\")\n\n# Sample Data\nsample_data = {\n    'Sample': ['Freshwater 1', 'Freshwater 2', 'Seawater', 'Brine 1', 'Brine 2', 'Acid Mine Drainage'],\n    'Ca': [60, 40, 15, 5, 2, 70],  # meq/L\n    'Mg': [20, 30, 5, 2, 1, 10],  # meq/L\n    'Na': [10, 20, 400, 1000, 2000, 5],  # meq/L\n    'K': [10, 10, 10, 5, 4, 15], # meq/L\n    'HCO3': [70, 60, 10, 2, 1, 5],  # meq/L\n    'SO4': [10, 20, 200, 500, 1000, 80],  # meq/L\n    'Cl': [5, 10, 400, 1000, 2000, 10],  # meq/L\n    'CO3': [15, 10, 0, 0, 0, 5], # meq/L\n    'Type': ['Freshwater', 'Freshwater', 'Seawater', 'Brine', 'Brine', 'Acid Mine Drainage']\n}\ndf = pd.DataFrame(sample_data)\n\n# Sidebar for User Input\nst.sidebar.header(\"Enter New Water Sample Data\")\nsample_name = st.sidebar.text_input(\"Sample Name\", \"New Sample\")\nca_input = st.sidebar.number_input(\"Ca\u00b2\u207a (meq/L)\", value=50.0)\nmg_input = st.sidebar.number_input(\"Mg\u00b2\u207a (meq/L)\", value=20.0)\nna_input = st.sidebar.number_input(\"Na\u207a (meq/L)\", value=10.0)\nk_input = st.sidebar.number_input(\"K\u207a (meq/L)\", value=10.0)\nhco3_input = st.sidebar.number_input(\"HCO\u2083\u207b (meq/L)\", value=60.0)\nso4_input = st.sidebar.number_input(\"SO\u2084\u00b2\u207b (meq/L)\", value=10.0)\ncl_input = st.sidebar.number_input(\"Cl\u207b (meq/L)\", value=5.0)\nco3_input = st.sidebar.number_input(\"CO\u2083\u00b2\u207b (meq/L)\", value=15.0)\nsample_type = st.sidebar.text_input(\"Sample Type\", \"User Defined\")\n\nadd_sample = st.sidebar.button(\"Add Sample\")\n\nif add_sample:\n    new_sample = {\n        'Sample': sample_name,\n        'Ca': ca_input,\n        'Mg': mg_input,\n        'Na': na_input,\n        'K': k_input,\n        'HCO3': hco3_input,\n        'SO4': so4_input,\n        'Cl': cl_input,\n        'CO3': co3_input,\n        'Type': sample_type\n    }\n    df = pd.concat([df, pd.DataFrame(new_sample, index=[0])], ignore_index=True)\n\n# Normalization Function\ndef normalize_ions(df):\n    df['Cations_Sum'] = df['Ca'] + df['Mg'] + df['Na'] + df['K']\n    df['Anions_Sum'] = df['HCO3'] + df['SO4'] + df['Cl'] + df['CO3']\n\n    df['Ca_percent'] = (df['Ca'] / df['Cations_Sum']) * 100\n    df['Mg_percent'] = (df['Mg'] / df['Cations_Sum']) * 100\n    df['NaK_percent'] = ((df['Na'] + df['K']) / df['Cations_Sum']) * 100\n\n    df['HCO3CO3_percent'] = ((df['HCO3'] + df['CO3']) / df['Anions_Sum']) * 100\n    df['SO4_percent'] = (df['SO4'] / df['Anions_Sum']) * 100\n    df['Cl_percent'] = (df['Cl'] / df['Anions_Sum']) * 100\n    return df\n\ndf = normalize_ions(df)\n\n# Sample Group Toggles\nst.sidebar.header(\"Toggle Sample Groups\")\nunique_types = df['Type'].unique()\nselected_types = {}\nfor water_type in unique_types:\n    selected_types[water_type] = st.sidebar.checkbox(water_type, value=True)\n\nfiltered_df = df[df['Type'].isin([k for k, v in selected_types.items() if v])]\n\n# Piper Diagram Plotting\nfig = go.Figure()\n\n# Get unique types *after* filtering\nunique_types_filtered = filtered_df['Type'].unique()\ncolor_map = {t: px.colors.qualitative.Dark24[i % len(px.colors.qualitative.Dark24)] for i, t in enumerate(unique_types_filtered)}\nfiltered_df['Color'] = filtered_df['Type'].map(color_map)\n\n\n# Cation Triangle\nfig.add_trace(go.Scatter(\n    x=filtered_df['Ca_percent'],\n    y=filtered_df['Mg_percent'],\n    mode='markers',\n    marker=dict(\n        size=10,\n        color=filtered_df['Color'],\n        line=dict(width=0.5, color='Black')\n    ),\n    text=[f\"Sample: {row['Sample']}<br>Ca: {row['Ca_percent']:.2f}%<br>Mg: {row['Mg_percent']:.2f}%<br>Na+K: {row['NaK_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\",\n    name=\"Cations\"\n))\n\n# Anion Triangle\nfig.add_trace(go.Scatter(\n    x=filtered_df['HCO3CO3_percent'] + 50,\n    y=filtered_df['SO4_percent'],\n    mode='markers',\n    marker=dict(\n        size=10,\n        color=filtered_df['Color'],\n        line=dict(width=0.5, color='Black')\n    ),\n    text=[f\"Sample: {row['Sample']}<br>HCO3+CO3: {row['HCO3CO3_percent']:.2f}%<br>SO4: {row['SO4_percent']:.2f}%<br>Cl: {row['Cl_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\",\n    name=\"Anions\"\n))\n\n# Diamond Plot (Approximate Calculation for Demonstration)\ndiamond_x = (filtered_df['Ca_percent'] + filtered_df['NaK_percent']*0 + (filtered_df['HCO3CO3_percent'] + 50) + (filtered_df['Cl_percent']*0 + 50) )/2\ndiamond_y = (filtered_df['Mg_percent']*0 + (100-filtered_df['NaK_percent']) + filtered_df['SO4_percent']*0 + (100 - filtered_df['Cl_percent']))/2\n\nfig.add_trace(go.Scatter(\n    x=diamond_x,\n    y=diamond_y,\n    mode='markers',\n    marker=dict(\n        size=10,\n        color=filtered_df['Color'],\n        line=dict(width=0.5, color='Black')\n    ),\n    text=[f\"Sample: {row['Sample']}<br>Ca: {row['Ca_percent']:.2f}%<br>Mg: {row['Mg_percent']:.2f}%<br>Na+K: {row['NaK_percent']:.2f}%<br>HCO3+CO3: {row['HCO3CO3_percent']:.2f}%<br>SO4: {row['SO4_percent']:.2f}%<br>Cl: {row['Cl_percent']:.2f}%\" for index, row in filtered_df.iterrows()],\n    hovertemplate=\"%{text}<extra></extra>\",\n    name=\"Diamond\"\n))\n\nfig.update_layout(\n    title=\"Piper Diagram\",\n    xaxis=dict(title=\"Cations (Ca, Mg, Na+K)\", range=[0, 100], showgrid=False),\n    yaxis=dict(title=\"Anions (HCO3+CO3, SO4, Cl)\", range=[0, 100], showgrid=False),\n    xaxis2=dict(title=\"HCO3+CO3\", overlaying='x', side='top', range=[50,150], showgrid=False),\n    yaxis2=dict(title=\"SO4\", overlaying='y', side='right', range=[0, 100], showgrid=False),\n    showlegend=True\n)\nfig.update_layout(xaxis2=dict(visible=False),\n                  yaxis2=dict(visible=False))\n\n#Add annotations for Piper Diagram regions\nfig.add_annotation(\n    text=\"Ca\",\n    x=0,\n    y=-0.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"Mg\",\n    x=0,\n    y=1.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"Na+K\",\n    x=1,\n    y=-0.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"HCO3+CO3\",\n    x=0.5,\n    y=1.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"SO4\",\n    x=1,\n    y=-0.1,\n    xref=\"paper\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nfig.add_annotation(\n    text=\"Cl\",\n    x=0,\n    y=-0.1,\n    xref=\"x2\",\n    yref=\"paper\",\n    showarrow=False\n)\n\nst.plotly_chart(fig, use_container_width=True)\n\n# Display Data Table\nst.header(\"Sample Data Table\")\nst.dataframe(filtered_df)",
    "title": "Interactive Piper Diagram for Water Chemistry Analysis",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "57cece56-75a9-4052-8283-e2eb812251fa": {
    "id": "57cece56-75a9-4052-8283-e2eb812251fa",
    "created_at": "2025-07-24T10:12:05.512258",
    "updated_at": "2025-07-24T10:13:25.432947",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Iris Dataset Visualization\")\nst.markdown(\"A simple scatter plot showing sepal length vs. sepal width, colored by species.\")\n\ntry:\n    iris_data = pd.read_csv('./upload/iris.csv')\nexcept FileNotFoundError:\n    st.error(\"Error: The file 'iris.csv' was not found in the './upload/' directory. Please upload the file.\")\n    st.stop()\n\n# Data Preview\nif st.checkbox(\"Show Raw Data\"):\n    st.subheader(\"Raw Data\")\n    st.dataframe(iris_data)\n\n\n# Scatter Plot\nst.subheader(\"Sepal Length vs. Sepal Width\")\n\n# Define a color palette (using Plotly's built-in palettes)\ncolor_palette = px.colors.qualitative.Dark24\n\n# Scatter Plot using Plotly Express (forced selection, Matplotlib option removed)\nfig = px.scatter(iris_data, x=\"sepal.length\", y=\"sepal.width\", color=\"variety\",\n                    labels={\"sepal.length\": \"Sepal Length (cm)\", \"sepal.width\": \"Sepal Width (cm)\", \"variety\": \"Species\"},\n                    title=\"Sepal Length vs. Sepal Width by Species (Plotly Express)\",\n                    color_discrete_sequence=color_palette)\nst.plotly_chart(fig, use_container_width=True)\n\n\n# Add some educational text\nst.markdown(\"---\")\nst.markdown(\"This plot visualizes the relationship between sepal length and sepal width for different species of Iris flowers. You can observe how the species tend to cluster based on these two features.\")",
    "title": "Iris Sepal Dimensions: Length vs. Width by Species",
    "description": "",
    "tags": [],
    "used_csv": "iris.csv"
  },
  "65bda23f-53b0-4788-9572-784e677b030e": {
    "id": "65bda23f-53b0-4788-9572-784e677b030e",
    "created_at": "2025-08-13T13:14:45.919230",
    "updated_at": "2025-08-13T13:14:45.919230",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Iris Data Visualization\")\n\n# Load Iris dataset\ntry:\n    from sklearn import datasets\n    iris = datasets.load_iris()\n    iris_df = pd.DataFrame(data=iris['data'], columns=iris['feature_names'])\n    iris_df['target'] = iris['target']\n    iris_df['species'] = pd.Categorical.from_codes(iris['target'], iris['target_names'])\nexcept:\n    # Sample data (if sklearn datasets fails, highly unlikely)\n    data = {'sepal length (cm)': [5.1, 4.9, 4.7, 4.6, 5.0, 7.0, 6.4, 6.9, 5.5, 6.5, 6.3, 5.8, 7.1, 6.3, 6.5, 7.6, 4.9, 7.3, 6.7, 7.2],\n            'sepal width (cm)': [3.5, 3.0, 3.2, 3.1, 3.6, 3.2, 3.2, 3.1, 2.3, 2.8, 2.5, 2.8, 3.0, 2.9, 3.0, 3.0, 2.5, 2.9, 2.5, 3.6],\n            'target': [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n            'species': ['setosa', 'setosa', 'setosa', 'setosa', 'setosa', 'versicolor', 'versicolor', 'versicolor', 'versicolor', 'versicolor', 'virginica', 'virginica', 'virginica', 'virginica', 'virginica', 'virginica', 'virginica', 'virginica', 'virginica', 'virginica']}\n    iris_df = pd.DataFrame(data)\n\n\n# Allow the user to select species to highlight\nselected_species = st.multiselect(\n    \"Select species to highlight:\",\n    options=iris_df['species'].unique(),\n    default=iris_df['species'].unique()  # Default: show all\n)\n\n# Filter data based on selected species\nfiltered_df = iris_df[iris_df['species'].isin(selected_species)]\n\n# Create the scatter plot using Plotly Express\nfig = px.scatter(\n    filtered_df,\n    x='sepal length (cm)',\n    y='sepal width (cm)',\n    color='species',\n    title='Sepal Length vs. Sepal Width (Colored by Species)',\n    labels={'sepal length (cm)': 'Sepal Length (cm)',\n            'sepal width (cm)': 'Sepal Width (cm)'}\n)\n\n# Update layout for better readability\nfig.update_layout(\n    title_x=0.5,\n    xaxis_title='Sepal Length (cm)',\n    yaxis_title='Sepal Width (cm)',\n    legend_title='Species'\n)\n\n# Display the plot in Streamlit\nst.plotly_chart(fig, use_container_width=True)\n\n# Add some educational text\nst.markdown(\"\"\"\nThis scatter plot visualizes the relationship between sepal length and sepal width for different Iris species. \nEach point represents an individual flower, and the color indicates its species: setosa, versicolor, or virginica.\nYou can select species to highlight using the multiselect box above.\n\"\"\")\n\n# Display the dataframe head\nst.subheader(\"Data Preview\")\nst.dataframe(iris_df.head())",
    "title": "Interactive Iris Data Visualization",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "45310695-9d72-4c46-8748-03a9168f2bb4": {
    "id": "45310695-9d72-4c46-8748-03a9168f2bb4",
    "created_at": "2025-08-13T14:36:25.738086",
    "updated_at": "2025-08-13T14:36:44.154400",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n# Sample Iris Data (using scikit-learn's built-in dataset)\nfrom sklearn.datasets import load_iris\niris = load_iris()\niris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)\niris_df['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)\n\nst.title(\"Iris Sepal Length vs. Sepal Width Scatter Plot\")\n\n# UI elements for interaction\nselected_species = st.multiselect(\n    \"Select Species (or leave blank for all):\",\n    options=iris_df['species'].unique().tolist(),\n    default=iris_df['species'].unique().tolist()\n)\n\n# Filter data based on selected species\nif selected_species:\n    filtered_iris_df = iris_df[iris_df['species'].isin(selected_species)]\nelse:\n    filtered_iris_df = iris_df\n\n# Create the scatter plot using Plotly Express\nfig = px.scatter(\n    filtered_iris_df,\n    x=\"sepal length (cm)\",\n    y=\"sepal width (cm)\",\n    color=\"species\",\n    title=\"Sepal Length vs. Sepal Width\",\n    labels={\"sepal length (cm)\": \"Sepal Length (cm)\",\n            \"sepal width (cm)\": \"Sepal Width (cm)\"}\n)\n\n# Display the plot in Streamlit\nst.plotly_chart(fig, use_container_width=True)\n\nst.subheader(\"Data Table\")\nst.dataframe(filtered_iris_df)",
    "title": "Iris Sepal Dimensions: Length vs. Width by Species",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "bb3d38ac-5082-40fa-a14c-fd48f7be03b8": {
    "id": "bb3d38ac-5082-40fa-a14c-fd48f7be03b8",
    "created_at": "2025-08-15T12:18:28.309305",
    "updated_at": "2025-08-15T12:18:28.309305",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\nst.title(\"Iris Dataset Visualization\")\n\n# Load the iris dataset (using a local copy for reproducibility)\n@st.cache_data\ndef load_data():\n    from sklearn.datasets import load_iris\n    iris_data = load_iris()\n    iris = pd.DataFrame(data= np.c_[iris_data['data'], iris_data['target']],\n                     columns= iris_data['feature_names'] + ['target'])\n    iris['species'] = pd.Categorical.from_codes(iris_data.target, iris_data.target_names)\n    return iris\niris = load_data()\n\nst.subheader(\"Original Dataframe\")\nst.dataframe(iris)\n\n# Create a scatter plot using Plotly Express\nst.subheader(\"Interactive Scatter Plot: Sepal Length vs. Sepal Width\")\nfig = px.scatter(iris, x=\"sepal length (cm)\", y=\"sepal width (cm)\", color=\"species\",\n                 title=\"Iris Data: Sepal Length vs. Sepal Width\",\n                 labels={\"sepal length (cm)\": \"Sepal Length (cm)\",\n                         \"sepal width (cm)\": \"Sepal Width (cm)\"})\nst.plotly_chart(fig, use_container_width=True)\n\n# Add some interactive elements\nst.sidebar.header(\"Scatter Plot Settings\")\n\n# Selectable species\nselected_species = st.sidebar.multiselect(\n    \"Select Species to Display\",\n    options=iris['species'].unique(),\n    default=iris['species'].unique()\n)\n\nfiltered_iris = iris[iris['species'].isin(selected_species)]\n\nif len(selected_species) > 0:\n    fig_filtered = px.scatter(filtered_iris, x=\"sepal length (cm)\", y=\"sepal width (cm)\", color=\"species\",\n                         title=\"Filtered Iris Data: Sepal Length vs. Sepal Width\",\n                         labels={\"sepal length (cm)\": \"Sepal Length (cm)\",\n                                 \"sepal width (cm)\": \"Sepal Width (cm)\"})\n    st.subheader(\"Filtered Scatter Plot\")\n    st.plotly_chart(fig_filtered, use_container_width=True)\nelse:\n    st.write(\"Please select at least one species to display.\")\n\n# Example of using matplotlib\nst.subheader(\"Matplotlib Scatter Plot\")\nfig_mpl, ax_mpl = plt.subplots()\nfor species in iris['species'].unique():\n    data = iris[iris['species'] == species]\n    ax_mpl.scatter(data['sepal length (cm)'], data['sepal width (cm)'], label=species)\nax_mpl.set_xlabel(\"Sepal Length (cm)\")\nax_mpl.set_ylabel(\"Sepal Width (cm)\")\nax_mpl.set_title(\"Matplotlib Scatter Plot\")\nax_mpl.legend()\nst.pyplot(fig_mpl)",
    "title": "Interactive Iris Dataset Visualization",
    "description": "",
    "tags": [],
    "used_csv": null
  },
  "82c61a67-d507-424b-8541-1609d49f3d5f": {
    "id": "82c61a67-d507-424b-8541-1609d49f3d5f",
    "created_at": "2025-08-29T10:43:50.185859",
    "updated_at": "2025-08-29T10:44:06.046249",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n# Suppress warnings to keep the output clean\nimport warnings\nwarnings.filterwarnings('ignore')\n# The option 'deprecation.showPyplotGlobalUse' was deprecated and removed in Streamlit 1.10.0\n# Removing this line resolves the StreamlitAPIException.\n\n# Load the Iris dataset from the specified CSV file\niris_df = pd.read_csv('./upload/iris.csv')\n\n# Set the title and a brief description for the Streamlit app\nst.title(\"Iris Dataset Pair Plot with Customizable Color Palette\")\nst.write(\"This interactive visualization displays the relationships between different features of the Iris flower dataset. Each point and distribution is colored according to the flower's variety. Use the sidebar to choose a color palette that best suits your viewing preference.\")\n\n# Create a sidebar for user interactions\nst.sidebar.header(\"Plot Settings\")\n\n# Define a list of suitable qualitative (categorical) color palettes from Seaborn.\n# These palettes are good for distinguishing different categories.\navailable_palettes = [\n    'Set1', 'tab10', 'deep', 'pastel', 'muted', 'bright', 'dark', 'colorblind',\n    'Set2', 'Set3', 'Paired', 'Accent', 'Dark2', 'husl', 'hls'\n]\n\n# Allow the user to select a color palette using a selectbox in the sidebar\nselected_palette = st.sidebar.selectbox(\n    \"Choose Color Palette:\",\n    options=available_palettes,\n    index=0 # 'Set1' is chosen as the default palette for its distinct colors\n)\n\n# Generate the pair plot using Seaborn.\n# 'hue' is set to 'variety' to color-code points and distributions by species.\n# 'diag_kind' is set to 'kde' to show Kernel Density Estimates on the diagonal,\n# which are smooth representations of the data distribution.\n# 'height' controls the size of each subplot, making them square and appropriately sized.\n# 'plot_kws' and 'diag_kws' are used to adjust the transparency (alpha)\n# and other visual properties of the scatter points and KDE plots for better readability.\npair_plot_grid = sns.pairplot(\n    iris_df,\n    hue='variety',\n    diag_kind='kde',\n    palette=selected_palette,\n    height=2.5, # Height of each facet (subplot) in inches\n    plot_kws={'alpha': 0.6, 's': 30}, # 'alpha' for transparency, 's' for marker size\n    diag_kws={'alpha': 0.5, 'lw': 1.5} # 'alpha' for transparency, 'lw' for line width\n)\n\n# Improve layout to prevent labels from overlapping\npair_plot_grid.fig.tight_layout()\n\n# Display the generated plot in the Streamlit app.\n# sns.pairplot returns a FacetGrid object, which has a '.fig' attribute\n# representing the underlying matplotlib figure.\nst.pyplot(pair_plot_grid.fig)\n\nst.write(f\"The pair plot above is currently displayed using the **'{selected_palette}'** color palette.\")\n\nst.write(\"---\") # Add a separator for better visual organization\n\n# Display a preview of the dataset\nst.subheader(\"Data Preview (First 5 Rows)\")\nst.dataframe(iris_df.head())\n\n# Display descriptive statistics of the dataset\nst.subheader(\"Dataset Description\")\nst.dataframe(iris_df.describe())\n\n# Add an educational explanation in the sidebar\nst.sidebar.subheader(\"About this Visualization\")\nst.sidebar.info(\n    \"A **Pair Plot**, also known as a scatter plot matrix, is an excellent tool for initial exploratory data analysis. \"\n    \"It visualizes the relationships between multiple numerical variables in a single grid. \"\n    \"\\n\\n- **Off-diagonal plots**: These are scatter plots showing the relationship between two different features (e.g., Sepal Length vs. Sepal Width). \"\n    \"Each point represents an individual Iris flower, and its color indicates its 'variety' (species). \"\n    \"\\n\\n- **Diagonal plots**: These show the distribution of a single feature. Here, Kernel Density Estimates (KDEs) \"\n    \"illustrate how the values for each feature are distributed across the different Iris varieties. \"\n    \"\\n\\nThis plot helps in quickly identifying patterns, correlations, and how distinct the different Iris varieties are based on their measurements. \"\n    \"Changing the color palette allows you to see the same data with different visual emphasis, which can sometimes reveal new insights or improve clarity.\"\n)",
    "title": "Iris Pair Plot: Customizable Color Palette",
    "description": "",
    "tags": [],
    "used_csv": "iris.csv",
    "used_image": "iris-dataset-1.png"
  },
  "d3fed070-48dd-4c20-9008-c3effb814602": {
    "id": "d3fed070-48dd-4c20-9008-c3effb814602",
    "created_at": "2025-08-29T11:03:05.342747",
    "updated_at": "2025-08-29T11:03:33.577717",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n# The 'deprecation.showPyplotGlobalUse' option has been removed in recent Streamlit versions.\n# Streamlit now handles Matplotlib global usage warnings automatically.\n# Remove the problematic line: st.set_option('deprecation.showPyplotGlobalUse', False)\n\n# The `st.set_page_config()` command must be the very first Streamlit command\n# in your script, and it can only be called once per app run.\n# Since this code is likely executed within another Streamlit application\n# (as indicated by the traceback from `safe_exec_visualization`),\n# `set_page_config` would have already been called by the parent app.\n# Calling it again here results in the `StreamlitSetPageConfigMustBeFirstCommandError`.\n# Therefore, remove the `st.set_page_config()` line.\n# If a wide layout is desired, it should be set by the main Streamlit application.\n\nst.title(\"Iris Dataset Pair Plot\")\n\n# Load the Iris dataset from the specified CSV file\niris_df = pd.read_csv('./upload/iris.csv')\n\n# --- Streamlit Sidebar for User Interaction ---\nst.sidebar.header(\"Plot Customization\")\n\n# Define a list of common Seaborn color palettes for the user to choose from\npalette_options = [\n    'deep', 'muted', 'pastel', 'bright', 'dark', 'colorblind',\n    'viridis', 'plasma', 'inferno', 'magma', 'cividis',\n    'rocket', 'mako', 'crest', 'flare', 'coolwarm', 'RdBu',\n    'cubehelix', 'Paired', 'Set1', 'Set2', 'Set3', 'tab10', 'tab20'\n]\n\n# Create a selectbox in the sidebar for the user to choose a color palette\nselected_palette = st.sidebar.selectbox(\n    \"Choose Color Palette:\",\n    palette_options,\n    index=0  # Default to 'deep'\n)\n\n# --- Main Content Area ---\nst.write(\"### Exploring Relationships Between Iris Flower Features\")\nst.write(f\"This visualization displays scatter plots for pairwise relationships and Kernel Density Estimate (KDE) plots for individual feature distributions in the Iris dataset.\")\nst.write(f\"The points and KDEs are colored by `variety` (corresponding to 'Species') using the **'{selected_palette}'** color palette, which you can change from the sidebar.\")\n\n# Create the Seaborn Pair Plot\n# The 'hue' parameter colors the data points based on the 'variety' column.\n# 'diag_kind=\"kde\"' ensures that the diagonal plots are Kernel Density Estimates,\n# matching the example image.\n# 'plot_kws' and 'diag_kws' are used to add transparency ('alpha') to the plots,\n# making overlapping points and distributions more visible, similar to the example.\npair_plot_figure = sns.pairplot(\n    iris_df,\n    hue='variety',\n    palette=selected_palette,\n    diag_kind='kde',\n    plot_kws={'alpha': 0.6},  # Alpha for scatter plot points\n    diag_kws={'alpha': 0.6}   # Alpha for diagonal KDE plots\n)\n\n# Customize the legend to match the example image:\n# 1. Set the legend title to \"Species\"\n# 2. Position the legend at the bottom center of the figure\n# 3. Arrange legend items horizontally in 3 columns\npair_plot_figure._legend.set_title(\"Species\")\npair_plot_figure._legend.set_loc('lower center')\npair_plot_figure._legend.set_bbox_to_anchor((0.5, 0)) # x, y for the center bottom\npair_plot_figure._legend.set_ncol(3) # Display legend items in 3 columns\n\n# Adjust the figure's subplot parameters to make space for the legend at the bottom\npair_plot_figure.fig.subplots_adjust(bottom=0.08)\n\n# Display the Matplotlib figure in Streamlit\nst.pyplot(pair_plot_figure.fig, use_container_width=True)\n\nst.write(\"---\")\nst.subheader(\"Raw Data Sample\")\nst.write(\"Here's a look at the first few rows of the Iris dataset:\")\nst.dataframe(iris_df.head())",
    "title": "Interactive Iris Feature Pair Plot",
    "description": "",
    "tags": [],
    "used_csv": "iris.csv",
    "used_image": "iris-dataset-1.png"
  },
  "2c4e5287-2e88-43fd-b60e-c07f3a6d4faa": {
    "id": "2c4e5287-2e88-43fd-b60e-c07f3a6d4faa",
    "created_at": "2025-08-29T11:13:15.801345",
    "updated_at": "2025-08-29T11:14:46.140905",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame # Not used in this visualization, but kept as per allowed imports\n\n# The option 'deprecation.showPyplotGlobalUse' was removed in recent Streamlit versions.\n# Removing this line resolves the StreamlitAPIException.\n# st.set_option('deprecation.showPyplotGlobalUse', False)\n\n# Load the data from the specified CSV file\ndf = pd.read_csv('./upload/iris.csv')\n\n# --- Streamlit App Layout ---\nst.title(\"Iris Dataset Pair Plot with Customizable Color Palette\")\n\nst.write(\n    \"This interactive visualization displays a pair plot of the Iris dataset, \"\n    \"showcasing the relationships between its numerical features, \"\n    \"categorized by species. On the diagonal, Kernel Density Estimates (KDEs) \"\n    \"illustrate the distribution of individual features. Off-diagonal plots \"\n    \"are scatter plots showing feature interactions.\"\n)\n\nst.write(\n    \"Use the sidebar to select a different color palette to highlight the 'variety' \"\n    \"of the Iris flowers. Experiment with various palettes to see how the visual \"\n    \"distinction between species changes.\"\n)\n\n# --- Sidebar for user interaction ---\nst.sidebar.header(\"Customization Options\")\n\n# Define a list of popular Seaborn color palettes\n# These palettes are generally good for categorical data (like 'variety') or sequential data\n# Pairplot will handle mapping colors from these palettes to the 'hue' categories.\npalette_options = [\n    'deep', 'pastel', 'muted', 'bright', 'dark', 'colorblind', # Categorical palettes\n    'viridis', 'plasma', 'magma', 'cividis', 'rocket', 'mako', # Sequential/perceptually uniform\n    'crest', 'flare', 'cubehelix', 'Spectral', 'RdBu' # More options\n]\n\n# Allow the user to select a color palette from the dropdown\nselected_palette = st.sidebar.selectbox(\n    \"Choose a Color Palette:\",\n    options=palette_options,\n    index=0 # Default to 'deep'\n)\n\n# --- Generate the Pair Plot ---\n# Identify the numerical features for the pair plot\nnumerical_features = ['sepal.length', 'sepal.width', 'petal.length', 'petal.width']\n\n# Create the Seaborn pair plot\n# hue='variety' colors the points and KDEs by the species\n# diag_kind='kde' displays Kernel Density Estimates on the diagonal\n# palette=selected_palette applies the chosen color scheme\n# plot_kws and diag_kws are used to set transparency (alpha) and marker size (s)\n# to match the style of the example image.\npair_plot_figure = sns.pairplot(\n    df,\n    vars=numerical_features,\n    hue='variety',\n    diag_kind='kde',\n    palette=selected_palette,\n    plot_kws={'alpha': 0.6, 's': 30}, # Transparency and size for scatter points\n    diag_kws={'alpha': 0.5}          # Transparency for KDE plots\n)\n\n# Add a title to the entire figure to provide context\npair_plot_figure.fig.suptitle(f\"Iris Species Feature Relationships (Palette: '{selected_palette}')\", y=1.02, fontsize=16)\n\n# Adjust layout to prevent labels/titles from overlapping\nplt.subplots_adjust(top=0.9, bottom=0.05, left=0.05, right=0.95, hspace=0.15, wspace=0.15)\n\n# Display the plot in Streamlit\nst.pyplot(pair_plot_figure)\n\n# --- Optional: Display Raw Data ---\nif st.sidebar.checkbox(\"Show Raw Data\"):\n    st.subheader(\"Raw Data\")\n    st.dataframe(df)",
    "title": "Iris Dataset Pair Plot with Customizable Color Palette",
    "description": "",
    "tags": [],
    "used_csv": "iris.csv",
    "used_image": "iris-dataset-1.png"
  },
  "4659c1ca-de87-4c40-951c-01fa569e6518": {
    "id": "4659c1ca-de87-4c40-951c-01fa569e6518",
    "created_at": "2025-09-11T14:39:42.223662",
    "updated_at": "2025-09-11T14:40:06.824996",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\n\n# Suppress specific deprecation warnings that might occur with older Streamlit versions or certain libraries\n# Note: The prompt asks to \"Do not generate output about deprecation.showPyplotGlobalUse.\"\n# This is generally handled by avoiding st.pyplot() if not necessary.\n# For Plotly Express, st.plotly_chart() is used and typically does not trigger this warning.\n# The 'deprecation.showPyplotGlobalUse' option was removed in newer Streamlit versions, causing an error.\n# Therefore, the line setting this option must be removed.\n\n# 1. Load the Iris dataset\n# plotly.express comes with built-in datasets, including Iris.\niris_data = px.data.iris()\n\n# Renaming columns to match the prompt's exact naming convention if different,\n# though px.data.iris() uses 'sepal_length', 'sepal_width' etc.\n# For consistency with the prompt's \"sepal.length\" and \"sepal.width\"\n# without actually renaming the dataframe columns, we will map them\n# or use the internal names 'sepal_length' and 'sepal_width' while defaulting\n# the UI to these. Since the prompt uses 'sepal.length' as a description,\n# and not a strict column name, we will stick with the actual column names in the dataset,\n# which are 'sepal_length', 'sepal_width', 'petal_length', 'petal_width', 'species', 'species_id'.\n\n# 2. Set up the Streamlit app title and description\nst.title(\"Interactive Iris Dataset Scatter Plot\")\nst.write(\"Visualize the famous Iris dataset to explore relationships between flower measurements and species.\")\n\n# 3. Create UI elements for student interaction\n# Get a list of all numeric columns for X and Y axis selection\nnumeric_columns = iris_data.select_dtypes(include=np.number).columns.tolist()\n\n# Get all columns for color dimension selection (can be numeric or categorical)\ncolor_columns = iris_data.columns.tolist()\n\n# Define default selections based on the problem description\ndefault_x_axis = \"sepal_length\"\ndefault_y_axis = \"sepal_width\"\ndefault_color_dimension = \"species\"\n\n# Find default indices for the selectboxes to ensure the specified defaults are pre-selected\ndefault_x_index = numeric_columns.index(default_x_axis) if default_x_axis in numeric_columns else 0\ndefault_y_index = numeric_columns.index(default_y_axis) if default_y_axis in numeric_columns else 0\ndefault_color_index = color_columns.index(default_color_dimension) if default_color_dimension in color_columns else 0\n\n# Selectbox for X-axis\nx_axis_choice = st.selectbox(\n    \"Select X-axis feature:\",\n    options=numeric_columns,\n    index=default_x_index,\n    key=\"x_axis_selector\"\n)\n\n# Selectbox for Y-axis\ny_axis_choice = st.selectbox(\n    \"Select Y-axis feature:\",\n    options=numeric_columns,\n    index=default_y_index,\n    key=\"y_axis_selector\"\n)\n\n# Selectbox for Color dimension\ncolor_choice = st.selectbox(\n    \"Select Color dimension:\",\n    options=color_columns,\n    index=default_color_index,\n    key=\"color_selector\"\n)\n\n# 4. Create the scatter plot using Plotly Express\n# The description requests \"sepal.length vs sepal.width and species as the color\",\n# which are set as default choices above.\nfig = px.scatter(\n    iris_data,\n    x=x_axis_choice,\n    y=y_axis_choice,\n    color=color_choice,\n    hover_name=\"species\", # Show species name on hover\n    title=f\"Scatter Plot of {y_axis_choice.replace('_', ' ').title()} vs {x_axis_choice.replace('_', ' ').title()} (Colored by {color_choice.replace('_', ' ').title()})\",\n    labels={\n        x_axis_choice: x_axis_choice.replace('_', ' ').title(),\n        y_axis_choice: y_axis_choice.replace('_', ' ').title(),\n        color_choice: color_choice.replace('_', ' ').title()\n    }\n)\n\n# Improve plot layout\nfig.update_layout(legend_title_text=color_choice.replace('_', ' ').title())\n\n# 5. Display the plot in Streamlit\nst.plotly_chart(fig, use_container_width=True)\n\n# 6. Add an option to view the raw data\nst.markdown(\"---\")\nst.subheader(\"Raw Data Display\")\nif st.checkbox(\"Show raw Iris dataset\", key=\"show_raw_data\"):\n    st.dataframe(iris_data)",
    "title": "Interactive Iris Scatter Plot",
    "description": "",
    "tags": [],
    "used_csv": null,
    "used_image": null
  },
  "8efea4f6-fbaa-49be-84eb-7fb5d51be070": {
    "id": "8efea4f6-fbaa-49be-84eb-7fb5d51be070",
    "created_at": "2025-10-06T12:48:46.467341",
    "updated_at": "2025-10-06T12:49:26.125397",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\nimport scipy\nimport math\nimport random\nimport datetime\nimport time\nimport json\nimport re\nimport os\nimport sys\nimport io\nimport collections\nimport itertools\nimport sklearn\nimport statsmodels\nimport statsmodels.api as sm\nimport altair as alt\nimport pygame\n\n# Load the data from the specified CSV file\nfile_path = './upload/wind_turbine_energy_generation.csv'\ndf = pd.read_csv(file_path)\n\n# --- Data Preprocessing ---\n# Convert 'timestamp' column to datetime objects\ndf['timestamp'] = pd.to_datetime(df['timestamp'])\n\n# Set 'timestamp' as the DataFrame index. This is crucial for 'method=\"time\"' interpolation.\ndf = df.set_index('timestamp')\n\n# Convert 'energy_output_kw' to numeric, coercing any errors (like empty strings) to NaN\ndf['energy_output_kw'] = pd.to_numeric(df['energy_output_kw'], errors='coerce')\n\n# Fill missing 'energy_output_kw' values. For time series, interpolation is often suitable\n# to maintain continuity. 'time' method interpolates based on time index.\ndf['energy_output_kw'] = df['energy_output_kw'].interpolate(method='time')\n\n# If there are still NaN values at the very beginning or end after interpolation (e.g., if first/last values were NaN),\n# fill them with 0, assuming no production when data is missing.\ndf['energy_output_kw'] = df['energy_output_kw'].fillna(0)\n\n# Reset the index to make 'timestamp' a regular column again, which is convenient for Plotly Express\ndf = df.reset_index()\n\n# Sort the DataFrame by timestamp to ensure the time series plot is ordered correctly\n# (This step is often redundant if the index was already sorted before reset_index, but harmless)\ndf = df.sort_values('timestamp')\n\n# --- Streamlit Visualization ---\nst.title(\"Wind Turbine Energy Production Over Time\")\n\nst.write(\n    \"Explore the energy output (in kW) of the wind turbine over different time periods. \"\n    \"Hover your mouse over the line to see detailed production values at specific times. \"\n    \"You can also use the interactive chart tools for zooming, panning, and selecting date ranges.\"\n)\n\n# --- UI Elements for Interaction ---\n# Determine the minimum and maximum dates in the dataset for the slider\nmin_available_date = df['timestamp'].min().date()\nmax_available_date = df['timestamp'].max().date()\n\n# Create a date range slider in the sidebar for filtering\nselected_date_range = st.sidebar.slider(\n    \"Select a Date Range:\",\n    min_value=min_available_date,\n    max_value=max_available_date,\n    value=(min_available_date, max_available_date), # Default to the full range\n    format=\"YYYY-MM-DD\"\n)\n\n# Filter the DataFrame based on the selected date range\nfiltered_df = df[\n    (df['timestamp'].dt.date >= selected_date_range[0]) &\n    (df['timestamp'].dt.date <= selected_date_range[1])\n]\n\n# --- Create Plotly Express Time Series Chart ---\nfig = px.line(\n    filtered_df,\n    x='timestamp',\n    y='energy_output_kw',\n    title='Energy Production (kW) Time Series',\n    labels={'timestamp': 'Date and Time', 'energy_output_kw': 'Energy Output (kW)'},\n    height=500\n)\n\n# Customize the hover tooltip for better readability\n# 'x unified' hover mode shows values for all traces at the current x-coordinate\nfig.update_layout(hovermode=\"x unified\")\nfig.update_traces(hovertemplate='<b>Time:</b> %{x}<br><b>Energy Output:</b> %{y:.2f} kW')\n\n# Add a range slider and range selector buttons to the x-axis for easier navigation\nfig.update_xaxes(\n    rangeslider_visible=True,\n    rangeselector=dict(\n        buttons=list([\n            dict(count=1, label=\"1h\", step=\"hour\", stepmode=\"backward\"),\n            dict(count=6, label=\"6h\", step=\"hour\", stepmode=\"backward\"),\n            dict(count=1, label=\"1d\", step=\"day\", stepmode=\"backward\"),\n            dict(count=7, label=\"1w\", step=\"day\", stepmode=\"backward\"),\n            dict(count=1, label=\"1m\", step=\"month\", stepmode=\"backward\"),\n            dict(step=\"all\")\n        ])\n    )\n)\n\n# Display the Plotly chart in Streamlit\nst.plotly_chart(fig, use_container_width=True)\n\nst.write(\"---\")\nst.write(\"#### First 10 Rows of Filtered Data\")\nst.dataframe(filtered_df.head(10)) # Show a sample of the data being plotted",
    "title": "Wind Turbine Energy Output Time Series",
    "description": "",
    "tags": [],
    "used_csv": "wind_turbine_energy_generation.csv",
    "used_image": null
  },
  "f593b6ea-1af4-4eac-af8f-6d1c774e64dc": {
    "id": "f593b6ea-1af4-4eac-af8f-6d1c774e64dc",
    "created_at": "2025-10-08T13:35:42.879770",
    "updated_at": "2025-10-08T13:36:10.195482",
    "code": "import streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.datasets import load_iris\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\nst.title(\"Iris Dataset Visualization\")\nst.write(\"Recreating a scatter plot showing Petal Width vs Petal Length for different Iris species\")\n\niris = load_iris()\niris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)\niris_df['species'] = iris.target\niris_df['species_name'] = iris_df['species'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})\n\npetal_length_col = st.selectbox(\"Select Petal Length Column\", iris_df.columns[:4], index=2)\npetal_width_col = st.selectbox(\"Select Petal Width Column\", iris_df.columns[:4], index=3)\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\nspecies_markers = {'setosa': 'o', 'versicolor': 's', 'virginica': '+'}\nspecies_colors = {'setosa': 'red', 'versicolor': 'blue', 'virginica': 'green'}\n\nfor species in ['setosa', 'versicolor', 'virginica']:\n    species_data = iris_df[iris_df['species_name'] == species]\n    ax.scatter(species_data[petal_length_col], \n               species_data[petal_width_col],\n               marker=species_markers[species],\n               color=species_colors[species],\n               label=species,\n               alpha=0.6,\n               s=60 if species != 'virginica' else 100,\n               linewidths=1.5 if species == 'virginica' else 1)\n\nax.set_xlabel('Petal.Length', fontsize=12)\nax.set_ylabel('Petal.Width', fontsize=12)\nax.legend(loc='upper left', frameon=True)\nax.grid(False)\nax.set_xlim(0.5, 7.5)\nax.set_ylim(-0.5, 3)\n\nplt.tight_layout()\nst.pyplot(fig)\n\nst.write(\"### Dataset Statistics\")\nst.dataframe(iris_df.groupby('species_name')[[petal_length_col, petal_width_col]].describe())",
    "title": "Iris Petal Dimensions by Species",
    "description": "",
    "tags": [],
    "used_csv": null,
    "used_image": "iris.png"
  },
  "9f109cfa-cc85-4c1f-a760-5a2ce81ffed5": {
    "id": "9f109cfa-cc85-4c1f-a760-5a2ce81ffed5",
    "created_at": "2025-10-08T13:39:36.100442",
    "updated_at": "2025-10-08T13:39:36.100442",
    "code": "import streamlit as st\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn import datasets\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\nst.title(\"Iris Dataset Visualization\")\nst.write(\"Recreating the scatter plot of Petal Length vs Petal Width by Species\")\n\n# Load the iris dataset\niris = datasets.load_iris()\niris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)\niris_df['species'] = iris.target\niris_df['species_name'] = iris_df['species'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Define colors and markers for each species\nspecies_styles = {\n    'setosa': {'color': 'red', 'marker': 'o', 'facecolors': 'none'},\n    'versicolor': {'color': 'blue', 'marker': '^', 'facecolors': 'none'},\n    'virginica': {'color': 'green', 'marker': '+', 'facecolors': 'green'}\n}\n\n# Plot each species\nfor species_name, style in species_styles.items():\n    species_data = iris_df[iris_df['species_name'] == species_name]\n    if species_name == 'virginica':\n        ax.scatter(species_data['petal length (cm)'], \n                  species_data['petal width (cm)'],\n                  c=style['color'], \n                  marker=style['marker'],\n                  s=80,\n                  label=species_name,\n                  linewidths=1.5)\n    else:\n        ax.scatter(species_data['petal length (cm)'], \n                  species_data['petal width (cm)'],\n                  edgecolors=style['color'], \n                  marker=style['marker'],\n                  facecolors=style['facecolors'],\n                  s=50,\n                  label=species_name,\n                  linewidths=1)\n\n# Set labels and title\nax.set_xlabel('Petal.Length', fontsize=12)\nax.set_ylabel('Petal.Width', fontsize=12)\nax.legend(loc='upper left', frameon=True)\nax.set_xlim(0.5, 7.5)\nax.set_ylim(0, 2.7)\n\n# Display the plot\nst.pyplot(fig)\n\n# Add interactive data exploration\nst.subheader(\"Interactive Data Exploration\")\n\nselected_species = st.multiselect(\n    \"Select species to display:\",\n    options=['setosa', 'versicolor', 'virginica'],\n    default=['setosa', 'versicolor', 'virginica']\n)\n\nif selected_species:\n    filtered_df = iris_df[iris_df['species_name'].isin(selected_species)]\n    st.write(f\"Showing {len(filtered_df)} samples\")\n    st.dataframe(filtered_df[['petal length (cm)', 'petal width (cm)', 'species_name']].head(20))\n    \n    # Summary statistics\n    st.subheader(\"Summary Statistics\")\n    summary = filtered_df.groupby('species_name')[['petal length (cm)', 'petal width (cm)']].describe()\n    st.dataframe(summary)",
    "title": "Iris Petal Dimensions by Species Visualization",
    "description": "",
    "tags": [],
    "used_csv": null,
    "used_image": "iris.png"
  }
}